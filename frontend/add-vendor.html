<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Add New Vendor - Contract Reconciliation Platform</title>
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <style>
        :root {
            --primary: #0f0f0f;
            --secondary: #1a1a1a;
            --accent: #2a2a2a;
            --border: #333;
            --text: #ffffff;
            --text-muted: #b0b0b0;
            --accent-cyan: #00d4ff;
            --accent-purple: #8b5cf6;
            --accent-success: #10b981;
            --accent-warning: #f59e0b;
            --accent-error: #ef4444;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            color: var(--text);
            min-height: 100vh;
            line-height: 1.6;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 40px 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            background: linear-gradient(135deg, var(--accent-cyan), var(--accent-purple));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .header p {
            color: var(--text-muted);
            font-size: 1.1rem;
        }

        .back-button {
            position: absolute;
            top: 30px;
            left: 30px;
            background: var(--secondary);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 10px 20px;
            border-radius: 8px;
            text-decoration: none;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.2s ease;
        }

        .back-button:hover {
            background: var(--accent);
            border-color: var(--accent-cyan);
        }

        .upload-section {
            background: var(--secondary);
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 40px;
            margin-bottom: 30px;
            text-align: center;
        }

        .upload-area {
            border: 2px dashed var(--border);
            border-radius: 12px;
            padding: 60px 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .upload-area:hover {
            border-color: var(--accent-cyan);
            background: rgba(0, 212, 255, 0.05);
        }

        .upload-area.drag-over {
            border-color: var(--accent-cyan);
            background: rgba(0, 212, 255, 0.1);
        }

        .upload-icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 20px;
            opacity: 0.6;
        }

        .upload-text {
            font-size: 1.3rem;
            margin-bottom: 10px;
            font-weight: 600;
        }

        .upload-subtext {
            color: var(--text-muted);
            margin-bottom: 20px;
        }

        .file-types {
            color: var(--text-muted);
            font-size: 0.9rem;
        }

        .processing-section {
            background: var(--secondary);
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 40px;
            margin-bottom: 30px;
            display: none;
        }

        .processing-title {
            text-align: center;
            margin-bottom: 30px;
            font-size: 1.5rem;
        }

        .progress-container {
            margin-bottom: 30px;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: var(--accent);
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 10px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent-cyan), var(--accent-purple));
            width: 0%;
            transition: width 0.3s ease;
        }

        .progress-text {
            color: var(--text-muted);
            text-align: center;
        }

        .vendor-form {
            background: var(--secondary);
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 40px;
            display: none;
        }

        .form-group {
            margin-bottom: 24px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: var(--text);
        }

        .form-group input,
        .form-group textarea {
            width: 100%;
            padding: 12px 16px;
            background: var(--primary);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text);
            font-size: 16px;
            transition: border-color 0.2s ease;
        }

        .form-group input:focus,
        .form-group textarea:focus {
            outline: none;
            border-color: var(--accent-cyan);
        }

        .form-group textarea {
            resize: vertical;
            min-height: 100px;
        }

        .required {
            color: var(--accent-error);
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            transition: all 0.2s ease;
            font-size: 16px;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--accent-cyan), var(--accent-purple));
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 212, 255, 0.3);
        }

        .btn-secondary {
            background: var(--accent);
            color: var(--text);
            border: 1px solid var(--border);
        }

        .btn-secondary:hover {
            background: var(--primary);
            border-color: var(--accent-cyan);
        }

        .form-actions {
            display: flex;
            gap: 16px;
            justify-content: center;
            margin-top: 30px;
        }

        .ai-insights {
            background: rgba(0, 212, 255, 0.1);
            border: 1px solid var(--accent-cyan);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 30px;
            display: none;
        }

        .ai-insights-title {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
            color: var(--accent-cyan);
            font-weight: 600;
        }

        .insight-item {
            background: var(--primary);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 10px;
        }

        .insight-label {
            font-weight: 600;
            color: var(--accent-cyan);
            margin-bottom: 4px;
        }

        .insight-value {
            color: var(--text-muted);
        }

        .toast-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 10000;
        }
        
        .toast {
            background: var(--secondary);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 16px 20px;
            margin-bottom: 10px;
            min-width: 300px;
            display: flex;
            align-items: center;
            gap: 12px;
            animation: slideIn 0.3s ease-out;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        
        .toast.success {
            border-left: 4px solid var(--accent-success);
        }
        
        .toast.error {
            border-left: 4px solid var(--accent-error);
        }
        
        .toast.warning {
            border-left: 4px solid var(--accent-warning);
        }
        
        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        @keyframes slideOut {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(100%);
                opacity: 0;
            }
        }
    </style>
    <!-- External Libraries -->
    <script src='https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js'></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    </script>
    <!-- Centralized Date Utilities -->
    <script src="js/date-utils.js"></script>
</head>
<body>
    <!-- Toast Container -->
    <div class="toast-container" id="toastContainer"></div>

    <a href="index.html" class="back-button">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M19 12H5M12 19l-7-7 7-7"/>
        </svg>
        Back to Dashboard
    </a>

    <div class="container">
        <div class="header">
            <h1>Add New Vendor</h1>
            <p>Upload a contract to automatically create a vendor profile</p>
        </div>

        <!-- Upload Section -->
        <div class="upload-section" id="uploadSection">
            <div class="upload-area" id="uploadArea" onclick="document.getElementById('contractFile').click()">
                <input type="file" id="contractFile" accept=".pdf,.doc,.docx,.jpg,.jpeg,.png,.tiff,.bmp" style="display: none;" onchange="handleFileSelect(event)">
                
                <svg class="upload-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                    <polyline points="14 2 14 8 20 8"></polyline>
                    <line x1="12" y1="11" x2="12" y2="17"></line>
                    <polyline points="9 14 12 11 15 14"></polyline>
                </svg>
                
                <div class="upload-text">Upload Contract Document</div>
                <div class="upload-subtext">Drag and drop your contract file or click to browse</div>
                <div class="file-types">Supports PDF, Word documents, and images</div>
            </div>
        </div>

        <!-- Processing Section -->
        <div class="processing-section" id="processingSection">
            <div class="processing-title">ü§ñ AI Analysis in Progress</div>
            <div class="processing-subtitle" id="processingSubtitle" style="text-align: center; color: var(--text-muted); margin-bottom: 20px; display: none;">
                Using GPT-4 Vision to analyze tables, charts, and structured content
            </div>
            <div class="progress-container">
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <div class="progress-text" id="progressText">Extracting text from contract...</div>
            </div>
        </div>

        <!-- AI Insights Section -->
        <div class="ai-insights" id="aiInsights">
            <div class="ai-insights-title">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="3"></circle>
                    <path d="M12 1v6m0 6v6m11-7h-6m-6 0H1"></path>
                </svg>
                AI Contract Insights
            </div>
            <div id="insightsContainer"></div>
        </div>

        <!-- Vendor Form -->
        <div class="vendor-form" id="vendorForm">
            <h2 style="margin-bottom: 30px; text-align: center;">Confirm Vendor Information</h2>
            <p style="text-align: center; color: var(--text-muted); margin-bottom: 30px;">
                Review the AI-extracted information and add any missing details
            </p>
            
            <form id="addVendorForm">
                <div class="form-group">
                    <label for="vendorName">Vendor Name <span class="required">*</span></label>
                    <input type="text" id="vendorName" name="vendorName" required>
                </div>
                
                <div class="form-group">
                    <label for="businessDescription">Service Category <span class="required">*</span></label>
                    <input type="text" id="businessDescription" name="businessDescription" placeholder="e.g., Waste Management, Medical Supplies, Food Services, Building Maintenance" required>
                </div>
                
                <div class="form-group">
                    <label for="effectiveDate">Contract Effective Date <span class="required">*</span></label>
                    <input type="date" id="effectiveDate" name="effectiveDate" required>
                </div>
                
                <div class="form-group">
                    <label for="renewalDate">Contract End/Renewal Date</label>
                    <input type="date" id="renewalDate" name="renewalDate">
                </div>
                
                <div class="form-group">
                    <label for="uploadDate">Date Added to System</label>
                    <input type="date" id="uploadDate" name="uploadDate" readonly style="background-color: rgba(255, 255, 255, 0.05); cursor: not-allowed;">
                </div>
                
                <div class="form-group">
                    <label for="notes">Invoice Reconciliation Terms <span class="required">*</span></label>
                    <textarea id="notes" name="notes" placeholder="Key terms for invoice reconciliation" rows="5" required></textarea>
                </div>
            </form>
            
            <div class="form-actions">
                <button type="button" class="btn btn-secondary" onclick="window.location.href='index.html'">Cancel</button>
                <button type="button" class="btn btn-primary" onclick="saveVendor()">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="20 6 9 17 4 12"></polyline>
                    </svg>
                    Create Vendor Profile
                </button>
            </div>
        </div>
    </div>

    <script>
        let uploadedFile = null;
        let contractAnalysis = null;
        let apiKey = localStorage.getItem('openai_api_key');
        let currentAnalysisController = null; // For cancellation

        // Toast notification system
        function showToast(message, type = 'info', duration = 5000) {
            const toastContainer = document.getElementById('toastContainer');
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            
            const icon = type === 'success' ? '‚úÖ' : type === 'error' ? '‚ùå' : type === 'warning' ? '‚ö†Ô∏è' : '‚ÑπÔ∏è';
            toast.innerHTML = `<span>${icon}</span><span>${message}</span>`;
            
            toastContainer.appendChild(toast);
            
            setTimeout(() => {
                toast.style.animation = 'slideOut 0.3s ease-in';
                setTimeout(() => toast.remove(), 300);
            }, duration);
        }

        // Drag and drop functionality
        document.addEventListener('DOMContentLoaded', function() {
            const uploadArea = document.getElementById('uploadArea');
            
            uploadArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadArea.classList.add('drag-over');
            });

            uploadArea.addEventListener('dragleave', () => {
                uploadArea.classList.remove('drag-over');
            });

            uploadArea.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadArea.classList.remove('drag-over');
                const files = Array.from(e.dataTransfer.files);
                if (files.length > 0) {
                    const file = files[0];
                    const errors = validateFile(file);
                    if (errors.length === 0) {
                        handleFileUpload(file);
                    } else {
                        showToast(errors.join(' '), 'error');
                    }
                }
            });

            // Check for API key
            if (!apiKey) {
                showToast('OpenAI API key not found. Please go to the main dashboard and set your API key in Settings.', 'warning');
                console.error('OpenAI API key not found in localStorage');
            } else {
                console.log('OpenAI API key found, ready to process contracts');
            }
        });

        function isValidFileType(file) {
            const validTypes = [
                'application/pdf',
                'application/msword',
                'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
                'image/jpeg',
                'image/jpg',
                'image/png',
                'image/tiff',
                'image/bmp'
            ];
            return validTypes.includes(file.type);
        }
        
        function validateFile(file) {
            const maxSize = 50 * 1024 * 1024; // 50MB limit
            const errors = [];
            
            if (!isValidFileType(file)) {
                errors.push(`File type "${file.type || 'unknown'}" is not supported. Please use PDF, Word, or image files.`);
            }
            
            if (file.size > maxSize) {
                errors.push(`File size (${(file.size / (1024 * 1024)).toFixed(1)}MB) exceeds the 50MB limit.`);
            }
            
            if (file.size === 0) {
                errors.push('File appears to be empty or corrupted.');
            }
            
            return errors;
        }

        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (file) {
                const errors = validateFile(file);
                if (errors.length === 0) {
                    handleFileUpload(file);
                } else {
                    showToast(errors.join(' '), 'error');
                }
            }
        }

        async function handleFileUpload(file) {
            if (!apiKey) {
                showToast('OpenAI API key required. Please set it in the main dashboard Settings.', 'error');
                return;
            }
            
            console.log('Processing file:', file.name, 'Type:', file.type, 'Size:', file.size);

            uploadedFile = file;
            
            // Show file preview
            showFilePreview(file);
            
            // Hide upload section, show processing
            document.getElementById('uploadSection').style.display = 'none';
            document.getElementById('processingSection').style.display = 'block';
            
            console.log(`Processing contract: ${file.name}`);
            
            try {
                // Step 1: Determine analysis method
                if (file.type.startsWith('image/')) {
                    updateProgress('Preparing for AI Vision analysis...', 10);
                } else if (file.type === 'application/pdf') {
                    updateProgress('Converting PDF pages for Vision analysis...', 10);
                } else {
                    updateProgress('Extracting text from contract...', 20);
                }
                
                // Step 2: Extract text (for fallback if needed)
                const contractText = await extractTextFromFile(file);
                
                // Step 3: Analyze with enhanced AI (Vision or Text)
                updateProgress('Analyzing contract with enhanced AI...', 50);
                contractAnalysis = await analyzeContract(contractText);
                
                console.log('Contract analysis result:', contractAnalysis);
                
                if (!contractAnalysis || !contractAnalysis.vendor_name) {
                    throw new Error('AI analysis did not extract vendor name');
                }
                
                // Step 3: Show insights
                updateProgress('Extracting vendor information...', 80);
                showAIInsights(contractAnalysis);
                
                // Step 4: Pre-fill form
                updateProgress('Preparing vendor form...', 100);
                prefillVendorForm(contractAnalysis);
                
                // Show final sections
                setTimeout(() => {
                    document.getElementById('processingSection').style.display = 'none';
                    document.getElementById('aiInsights').style.display = 'block';
                    document.getElementById('vendorForm').style.display = 'block';
                    console.log('Contract analysis complete! Review and complete the vendor profile.');
                }, 1000);
                
            } catch (error) {
                console.error('Error processing contract:', error);
                showToast(`Contract processing failed: ${error.message}`, 'error');
                document.getElementById('processingSection').style.display = 'none';
                document.getElementById('uploadSection').style.display = 'block';
                
                // Reset state
                uploadedFile = null;
                contractAnalysis = null;
            }
        }

        function updateProgress(message, percentage) {
            document.getElementById('progressFill').style.width = percentage + '%';
            document.getElementById('progressText').textContent = message;
            
            // Add cancel button during processing
            const progressContainer = document.querySelector('.progress-container');
            let cancelBtn = progressContainer.querySelector('.cancel-btn');
            
            if (percentage > 0 && percentage < 100 && !cancelBtn) {
                cancelBtn = document.createElement('button');
                cancelBtn.className = 'cancel-btn';
                cancelBtn.innerHTML = '‚úï Cancel';
                cancelBtn.style.cssText = 'margin-top: 10px; padding: 8px 16px; background: var(--error); color: white; border: none; border-radius: 4px; cursor: pointer;';
                cancelBtn.onclick = cancelAnalysis;
                progressContainer.appendChild(cancelBtn);
            } else if (percentage >= 100 && cancelBtn) {
                cancelBtn.remove();
            }
        }
        
        function cancelAnalysis() {
            if (currentAnalysisController) {
                currentAnalysisController.abort();
            }
            
            // Reset UI
            document.getElementById('uploadSection').style.display = 'block';
            document.getElementById('processingSection').style.display = 'none';
            document.getElementById('aiInsights').style.display = 'none';
            document.getElementById('vendorForm').style.display = 'none';
            
            // Clear state
            uploadedFile = null;
            contractAnalysis = null;
            currentAnalysisController = null;
            
            showToast('Analysis cancelled', 'info');
        }
        
        function showFilePreview(file) {
            const processingSection = document.getElementById('processingSection');
            let previewDiv = processingSection.querySelector('.file-preview');
            
            if (!previewDiv) {
                previewDiv = document.createElement('div');
                previewDiv.className = 'file-preview';
                previewDiv.style.cssText = 'margin-bottom: 20px; padding: 15px; background: rgba(30, 41, 59, 0.5); border-radius: 8px; border: 1px solid var(--border);';
                processingSection.insertBefore(previewDiv, processingSection.firstChild);
            }
            
            const fileSize = (file.size / (1024 * 1024)).toFixed(1);
            const fileIcon = getFileIcon(file.type);
            
            previewDiv.innerHTML = `
                <div style="display: flex; align-items: center; gap: 12px;">
                    <div style="font-size: 24px;">${fileIcon}</div>
                    <div>
                        <div style="font-weight: 500; color: var(--text-primary);">${file.name}</div>
                        <div style="font-size: 12px; color: var(--text-secondary);">${file.type} ‚Ä¢ ${fileSize}MB</div>
                    </div>
                </div>
            `;
        }
        
        function getFileIcon(fileType) {
            if (fileType === 'application/pdf') return 'üìÑ';
            if (fileType.startsWith('image/')) return 'üñºÔ∏è';
            if (fileType.includes('word')) return 'üìÑ';
            return 'üìÅ';
        }
        
        let draftSaveTimeout;
        function saveDraft() {
            clearTimeout(draftSaveTimeout);
            draftSaveTimeout = setTimeout(() => {
                const form = document.getElementById('addVendorForm');
                if (!form) return;
                
                const formData = new FormData(form);
                const draft = {
                    vendorName: formData.get('vendorName') || '',
                    businessDescription: formData.get('businessDescription') || '',
                    effectiveDate: formData.get('effectiveDate') || '',
                    renewalDate: formData.get('renewalDate') || '',
                    uploadDate: formData.get('uploadDate') || getTodayForInput(),
                    notes: formData.get('notes') || '',
                    timestamp: Date.now()
                };
                
                localStorage.setItem('vendor_draft', JSON.stringify(draft));
                
                // Show brief save indicator
                showSaveIndicator();
            }, 1000);
        }
        
        function loadDraft() {
            const draft = localStorage.getItem('vendor_draft');
            if (!draft) return;
            
            try {
                const draftData = JSON.parse(draft);
                const age = Date.now() - draftData.timestamp;
                
                // Only load drafts less than 24 hours old
                if (age < 24 * 60 * 60 * 1000) {
                    document.getElementById('vendorName').value = draftData.vendorName || '';
                    document.getElementById('businessDescription').value = draftData.businessDescription || '';
                    document.getElementById('effectiveDate').value = draftData.effectiveDate || draftData.contractDate || '';
                    document.getElementById('renewalDate').value = draftData.renewalDate || '';
                    document.getElementById('uploadDate').value = draftData.uploadDate || getTodayForInput();
                    document.getElementById('notes').value = draftData.notes || '';
                    
                    if (draftData.vendorName || draftData.businessDescription) {
                        showToast('Draft data restored', 'info');
                    }
                }
            } catch (e) {
                console.error('Error loading draft:', e);
            }
        }
        
        function clearDraft() {
            localStorage.removeItem('vendor_draft');
        }
        
        function showSaveIndicator() {
            let indicator = document.querySelector('.save-indicator');
            if (!indicator) {
                indicator = document.createElement('div');
                indicator.className = 'save-indicator';
                indicator.style.cssText = 'position: fixed; top: 20px; right: 20px; background: var(--success); color: white; padding: 8px 16px; border-radius: 4px; font-size: 12px; z-index: 1000; opacity: 0; transition: opacity 0.3s;';
                indicator.textContent = '‚úì Draft saved';
                document.body.appendChild(indicator);
            }
            
            indicator.style.opacity = '1';
            setTimeout(() => {
                indicator.style.opacity = '0';
            }, 2000);
        }

        async function extractTextFromFile(file) {
            const fileType = file.type;
            
            if (fileType === 'application/pdf') {
                return await extractTextFromPDF(file);
            } else if (fileType.startsWith('image/')) {
                return await extractTextFromImage(file);
            } else if (fileType.includes('word')) {
                // For Word documents, we'll treat them as text for now
                showToast('Word document detected. For best results, please convert to PDF first.', 'warning');
                return await extractTextFromImage(file); // Fallback to OCR
            }
            
            throw new Error('Unsupported file type');
        }

        async function extractTextFromPDF(file) {
            const arrayBuffer = await file.arrayBuffer();
            const pdf = await pdfjsLib.getDocument(arrayBuffer).promise;
            let fullText = '';
            
            for (let i = 1; i <= pdf.numPages; i++) {
                const page = await pdf.getPage(i);
                const textContent = await page.getTextContent();
                const pageText = textContent.items.map(item => item.str).join(' ');
                fullText += pageText + '\\n';
            }
            
            return fullText;
        }

        async function extractTextFromImage(file) {
            const { data: { text } } = await Tesseract.recognize(file, 'eng', {
                logger: m => {
                    if (m.status === 'recognizing text') {
                        updateProgress(`OCR Processing: ${Math.round(m.progress * 100)}%`, 30 + (m.progress * 20));
                    }
                }
            });
            return text;
        }

        async function analyzeContract(text) {
            // First try GPT-4 Vision if we have the original file as an image
            if (uploadedFile && uploadedFile.type.startsWith('image/')) {
                return await analyzeContractWithVision(uploadedFile);
            }
            
            // For PDFs, convert to images and use vision
            if (uploadedFile && uploadedFile.type === 'application/pdf') {
                return await analyzeContractPDFWithVision(uploadedFile);
            }
            
            // Fallback to text analysis for other cases
            return await analyzeContractWithText(text);
        }

        async function analyzeContractWithVision(imageFile) {
            const prompt = `Carefully analyze this ENTIRE contract image. Look at ALL sections, tables, and lists.

CRITICAL DATE EXTRACTION INSTRUCTIONS:
- PRIORITY: Find the EXACT effective date by looking for these specific phrases:
  * "effective date" followed by a date
  * "effective as of" followed by a date  
  * "commencing on" followed by a date
  * "this agreement shall be effective" followed by a date
  * "beginning" followed by a date
  * "starts on" or "starting" followed by a date
- SCAN THE ENTIRE FIRST PAGE for date information - effective dates are usually stated early
- If you see "January 1, 2025" or "1/1/2025" or "01/01/2025" mentioned as an effective date, use "2025-01-01"
- MANDATORY: Calculate renewal date if you find ANY term length:
  * "three year" or "3 year" or "three-year" = add 3 years
  * "five year" or "5 year" = add 5 years  
  * "36 month" or "thirty-six month" = add 3 years
  * "24 month" or "two year" = add 2 years
- EXAMPLE CALCULATION: If effective_date is "2025-01-01" and you see "three year term", renewal_date MUST be "2028-01-01"
- DO NOT leave renewal_date null if you find any term language
- BE CONSISTENT: Same date in both fields, just different formats

Extract:
1. The vendor/supplier company name
2. Service category in 2-3 words (e.g., "Waste Management", "Medical Supplies", "IT Services")
3. The EXACT contract effective date from the document
4. The contract end/renewal date (either stated directly OR calculated from effective date + term length)
5. A comprehensive 3-5 sentence summary of ALL terms relevant for invoice reconciliation

DATE EXTRACTION RULES - FOLLOW THESE EXACTLY:
- Look for "effective" + date: "effective January 1, 2025" ‚Üí effective_date: "2025-01-01"
- Look for "commencing" + date: "commencing January 1, 2025" ‚Üí effective_date: "2025-01-01"  
- Look for "beginning" + date: "beginning January 1, 2025" ‚Üí effective_date: "2025-01-01"
- MANDATORY CALCULATION: If you find "three year" or "3 year" anywhere in contract + effective_date "2025-01-01" ‚Üí renewal_date: "2028-01-01"
- MANDATORY CALCULATION: If you find "five year" or "5 year" anywhere in contract + effective_date "2025-01-01" ‚Üí renewal_date: "2030-01-01"
- MANDATORY CALCULATION: If you find "36 month" anywhere in contract + effective_date "2025-01-01" ‚Üí renewal_date: "2028-01-01"
- DO NOT leave renewal_date as null if you see ANY term length mentioned
- Example: "This agreement is effective January 1, 2025 for an initial term of three years" ‚Üí effective_date: "2025-01-01", renewal_date: "2028-01-01"

Pay special attention to:
- The FIRST section of the contract where dates are usually stated
- Term/duration language (years, months, "initial term", "renewal term")
- Automatic renewal clauses
- Tables showing pricing or fees
- Payment schedules and billing terms

Return ONLY this JSON:
{
  "vendor_name": "[exact vendor name]",
  "business_description": "[2-3 word service category]",
  "effective_date": "[YYYY-MM-DD format - the exact date found in contract]",
  "renewal_date": "[YYYY-MM-DD format - either stated OR calculated from effective date + term]",
  "reconciliation_summary": "[comprehensive summary including term length, renewal provisions, and ALL payment terms]"
}`;

            try {
                // Convert image to base64
                const base64Image = await fileToBase64(imageFile);
                
                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: 'gpt-4o',
                        messages: [
                            {
                                role: "system",
                                content: "You are an expert contract analyst. CRITICAL RULES: 1) Extract the EXACT effective date from the contract. 2) If you find a term length (e.g., 'three-year term'), YOU MUST calculate the renewal_date by adding the term to the effective date. Example: Effective 2025-01-01 + three years = renewal_date: 2028-01-01. 3) The effective_date field and the date in reconciliation_summary MUST match. 4) ALWAYS fill in renewal_date if term length is mentioned. 5) Use 2-3 word service category. Format ALL dates as YYYY-MM-DD. Return ONLY valid JSON with calculated dates."
                            },
                            {
                                role: "user",
                                content: [
                                    {
                                        type: "text",
                                        text: prompt
                                    },
                                    {
                                        type: "image_url",
                                        image_url: {
                                            url: base64Image,
                                            detail: "high"
                                        }
                                    }
                                ]
                            }
                        ],
                        // response_format: { type: "json_object" }, // May not work with vision
                        max_tokens: 2000,
                        temperature: 0.1
                    })
                });
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('OpenAI API Error:', errorText);
                    throw new Error(`OpenAI Vision API request failed: ${response.status} - ${errorText}`);
                }
                
                const data = await response.json();
                console.log('OpenAI API response:', data);
                
                if (!data.choices || !data.choices[0] || !data.choices[0].message) {
                    throw new Error('Invalid API response structure');
                }
                
                const content = data.choices[0].message.content;
                console.log('API content:', content);
                
                const parsedResponse = parseAIResponse(content);
                console.log('Parsed AI response with dates:', parsedResponse);
                return parsedResponse;
                
            } catch (error) {
                console.error('AI Vision analysis error:', error);
                // Don't fall back to OCR - just try text analysis with better prompt
                console.log('Vision analysis encountered an issue, trying alternative method');
                
                // Try to get text without OCR
                if (uploadedFile && uploadedFile.type === 'application/pdf') {
                    const text = await extractTextFromPDF(uploadedFile);
                    return await analyzeContractWithText(text);
                }
                
                // For images, we really need vision to work
                throw new Error('Unable to analyze image contract. Please try a PDF version.');
            }
        }

        async function analyzeContractPDFWithVision(pdfFile) {
            try {
                // Convert PDF to images for vision analysis
                const arrayBuffer = await pdfFile.arrayBuffer();
                const pdf = await pdfjsLib.getDocument(arrayBuffer).promise;
                
                // Analyze ALL pages to get complete contract information
                const maxPages = Math.min(10, pdf.numPages); // Analyze up to 10 pages
                let combinedAnalysis = null;
                
                for (let pageNum = 1; pageNum <= maxPages; pageNum++) {
                    updateProgress(`Analyzing page ${pageNum} with AI Vision...`, 50 + (pageNum * 10));
                    
                    const page = await pdf.getPage(pageNum);
                    const viewport = page.getViewport({ scale: 2.0 }); // Higher resolution
                    
                    // Render page to canvas
                    const canvas = document.createElement('canvas');
                    const context = canvas.getContext('2d');
                    canvas.height = viewport.height;
                    canvas.width = viewport.width;
                    
                    await page.render({
                        canvasContext: context,
                        viewport: viewport
                    }).promise;
                    
                    // Convert canvas to blob
                    const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/png'));
                    
                    // Analyze this page with vision
                    const pageAnalysis = await analyzeContractWithVision(blob);
                    
                    // Combine results from multiple pages (simplified structure)
                    if (!combinedAnalysis) {
                        combinedAnalysis = pageAnalysis;
                    } else {
                        // Keep vendor name from first occurrence
                        if (!combinedAnalysis.vendor_name && pageAnalysis.vendor_name) {
                            combinedAnalysis.vendor_name = pageAnalysis.vendor_name;
                        }
                        
                        // Keep business description from first good occurrence
                        if (!combinedAnalysis.business_description && pageAnalysis.business_description) {
                            combinedAnalysis.business_description = pageAnalysis.business_description;
                        }
                        
                        // Combine summaries from all pages for comprehensive coverage
                        if (pageAnalysis.reconciliation_summary && pageAnalysis.reconciliation_summary !== "Unable to extract contract terms. Please review the contract manually.") {
                            if (combinedAnalysis.reconciliation_summary && 
                                combinedAnalysis.reconciliation_summary !== "Unable to extract contract terms. Please review the contract manually.") {
                                // Append new information from this page
                                combinedAnalysis.reconciliation_summary += " " + pageAnalysis.reconciliation_summary;
                            } else {
                                // Replace with better summary
                                combinedAnalysis.reconciliation_summary = pageAnalysis.reconciliation_summary;
                            }
                        }
                    }
                }
                
                return combinedAnalysis;
                
            } catch (error) {
                console.error('PDF Vision analysis error:', error);
                console.log('Vision analysis issue, using text extraction');
                // Extract text directly from PDF without OCR
                const text = await extractTextFromPDF(pdfFile);
                return await analyzeContractWithText(text);
            }
        }

        async function analyzeContractWithText(text) {
            const prompt = `Read this ENTIRE contract carefully.

CRITICAL DATE EXTRACTION INSTRUCTIONS:
- PRIORITY: Find the EXACT effective date by looking for these specific phrases:
  * "effective date" followed by a date
  * "effective as of" followed by a date  
  * "commencing on" followed by a date
  * "this agreement shall be effective" followed by a date
  * "beginning" followed by a date
  * "starts on" or "starting" followed by a date
- SCAN THE ENTIRE FIRST PAGE for date information - effective dates are usually stated early
- If you see "January 1, 2025" or "1/1/2025" or "01/01/2025" mentioned as an effective date, use "2025-01-01"
- MANDATORY: Calculate renewal date if you find ANY term length:
  * "three year" or "3 year" or "three-year" = add 3 years
  * "five year" or "5 year" = add 5 years  
  * "36 month" or "thirty-six month" = add 3 years
  * "24 month" or "two year" = add 2 years
- EXAMPLE CALCULATION: If effective_date is "2025-01-01" and you see "three year term", renewal_date MUST be "2028-01-01"
- DO NOT leave renewal_date null if you find any term language
- BE CONSISTENT: Same date in both fields, just different formats

Extract:
1. The vendor/supplier company name
2. Service category in 2-3 words (e.g., "Waste Management", "Medical Supplies", "IT Services")
3. The EXACT contract effective date from the document
4. The contract end/renewal date (either stated directly OR calculated from effective date + term length)
5. A comprehensive 3-5 sentence summary of ALL terms relevant for invoice reconciliation

DATE EXTRACTION RULES - FOLLOW THESE EXACTLY:
- Look for "effective" + date: "effective January 1, 2025" ‚Üí effective_date: "2025-01-01"
- Look for "commencing" + date: "commencing January 1, 2025" ‚Üí effective_date: "2025-01-01"  
- Look for "beginning" + date: "beginning January 1, 2025" ‚Üí effective_date: "2025-01-01"
- MANDATORY CALCULATION: If you find "three year" or "3 year" anywhere in contract + effective_date "2025-01-01" ‚Üí renewal_date: "2028-01-01"
- MANDATORY CALCULATION: If you find "five year" or "5 year" anywhere in contract + effective_date "2025-01-01" ‚Üí renewal_date: "2030-01-01"
- MANDATORY CALCULATION: If you find "36 month" anywhere in contract + effective_date "2025-01-01" ‚Üí renewal_date: "2028-01-01"
- DO NOT leave renewal_date as null if you see ANY term length mentioned
- Example: "This agreement is effective January 1, 2025 for an initial term of three years" ‚Üí effective_date: "2025-01-01", renewal_date: "2028-01-01"

IMPORTANT: Include ALL of these if present:
- The EXACT dates mentioned in the contract
- Term/duration (convert to end date)
- Automatic renewal provisions
- All payment amounts and fees
- Billing frequency and invoice schedule
- Payment terms (Net 30, etc.)
- All services provided

Contract text:
${text.substring(0, 15000)}

Return ONLY this JSON:
{
  "vendor_name": "[exact vendor name]",
  "business_description": "[2-3 word service category]",
  "effective_date": "[YYYY-MM-DD format - the exact date found in contract]",
  "renewal_date": "[YYYY-MM-DD format - either stated OR calculated from effective date + term]",
  "reconciliation_summary": "[comprehensive summary including term length, renewal provisions, and ALL payment terms]"
}`;

            try {
                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: 'gpt-4o',
                        messages: [
                            {
                                role: "system",
                                content: "You are an expert contract analyst. CRITICAL RULES: 1) Extract the EXACT effective date from the contract. 2) If you find a term length (e.g., 'three-year term'), YOU MUST calculate the renewal_date by adding the term to the effective date. Example: Effective 2025-01-01 + three years = renewal_date: 2028-01-01. 3) The effective_date field and the date in reconciliation_summary MUST match. 4) ALWAYS fill in renewal_date if term length is mentioned. 5) Use 2-3 word service category. Format ALL dates as YYYY-MM-DD. Return ONLY valid JSON with calculated dates."
                            },
                            {
                                role: "user", 
                                content: prompt
                            }
                        ],
                        // response_format: { type: "json_object" }, // May not work with vision
                        temperature: 0.1,
                        max_tokens: 2000
                    })
                });
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('OpenAI API Error:', errorText);
                    throw new Error(`OpenAI API request failed: ${response.status} - ${errorText}`);
                }
                
                const data = await response.json();
                console.log('OpenAI API response:', data);
                
                if (!data.choices || !data.choices[0] || !data.choices[0].message) {
                    throw new Error('Invalid API response structure');
                }
                
                const content = data.choices[0].message.content;
                console.log('API content:', content);
                
                const parsedResponse = parseAIResponse(content);
                console.log('Parsed AI response with dates:', parsedResponse);
                return parsedResponse;
                
            } catch (error) {
                console.error('AI text analysis error:', error);
                showToast(`Contract analysis failed: ${error.message}`, 'error');
                throw error;
            }
        }

        function formatDateForSummary(dateStr) {
            // Use centralized date formatting for summary (MM/DD/YYYY format)
            return formatDateForDisplay(dateStr);
        }
        
        function fixDateInSummary(summary, correctDate) {
            // Fix date inconsistencies in the summary
            const correctDateFormatted = formatDateForSummary(correctDate);
            
            // Common date patterns to replace
            const datePatterns = [
                /January \d{1,2}, \d{4}/g,
                /February \d{1,2}, \d{4}/g,
                /March \d{1,2}, \d{4}/g,
                /April \d{1,2}, \d{4}/g,
                /May \d{1,2}, \d{4}/g,
                /June \d{1,2}, \d{4}/g,
                /July \d{1,2}, \d{4}/g,
                /August \d{1,2}, \d{4}/g,
                /September \d{1,2}, \d{4}/g,
                /October \d{1,2}, \d{4}/g,
                /November \d{1,2}, \d{4}/g,
                /December \d{1,2}, \d{4}/g,
                /\d{1,2}\/\d{1,2}\/\d{4}/g,
                /\d{1,2}-\d{1,2}-\d{4}/g
            ];
            
            let fixedSummary = summary;
            let foundDate = false;
            
            // Try to find and replace the first date that looks like an effective date
            for (const pattern of datePatterns) {
                const matches = summary.match(pattern);
                if (matches && matches.length > 0) {
                    // Replace the first occurrence (likely the effective date)
                    fixedSummary = summary.replace(matches[0], correctDateFormatted);
                    foundDate = true;
                    break;
                }
            }
            
            if (!foundDate) {
                // If no date found, prepend the correct date to the summary
                fixedSummary = `The contract is effective from ${correctDateFormatted}. ${summary}`;
            }
            
            return fixedSummary;
        }
        
        // Note: formatDate is now provided by date-utils.js
        // Legacy wrapper for compatibility
        function formatDateLegacy(dateStr) {
            if (!dateStr || dateStr === 'null') return 'Not specified';
            const formatted = formatDateForDisplay(dateStr);
            return formatted || 'Not specified';
        }
        
        function parseContractDate(dateStr) {
            // Use centralized date parsing and return in YYYY-MM-DD format for HTML inputs
            return formatDateForInput(dateStr);
        }
        
        function extractDatesFromSummary(summary) {
            // Extract effective date from summary text
            if (!summary) return {};
            
            const effectiveDatePatterns = [
                /effective\s+from\s+([a-zA-Z]+ \d{1,2}, \d{4})/gi,
                /effective\s+as\s+of\s+([a-zA-Z]+ \d{1,2}, \d{4})/gi,
                /effective\s+([a-zA-Z]+ \d{1,2}, \d{4})/gi,
                /commencing\s+on\s+([a-zA-Z]+ \d{1,2}, \d{4})/gi,
                /beginning\s+([a-zA-Z]+ \d{1,2}, \d{4})/gi,
                /starts\s+on\s+([a-zA-Z]+ \d{1,2}, \d{4})/gi,
                /effective\s+from\s+(\d{1,2}\/\d{1,2}\/\d{4})/gi,
                /effective\s+(\d{1,2}\/\d{1,2}\/\d{4})/gi
            ];
            
            let effectiveDate = null;
            
            for (const pattern of effectiveDatePatterns) {
                const matches = [...summary.matchAll(pattern)];
                if (matches.length > 0) {
                    const dateStr = matches[0][1];
                    effectiveDate = formatDateForInput(dateStr);
                    console.log(`Found effective date in summary: "${dateStr}" ‚Üí ${effectiveDate}`);
                    break;
                }
            }
            
            return { effectiveDate };
        }
        
        function calculateRenewalDate(effectiveDate, summary) {
            // Extract term information from the summary and calculate renewal date
            if (!effectiveDate || !summary) {
                console.log('Cannot calculate renewal date - missing effective date or summary');
                return null;
            }
            
            console.log('Calculating renewal date from:', { effectiveDate, summary: summary.substring(0, 200) });
            
            const summaryLower = summary.toLowerCase();
            let years = 0;
            let months = 0;
            
            // Enhanced patterns to catch more variations
            const termPatterns = [
                // Word-based year patterns
                { pattern: /\bthree[\s-]*year/gi, years: 3 },
                { pattern: /\bfive[\s-]*year/gi, years: 5 },
                { pattern: /\bone[\s-]*year/gi, years: 1 },
                { pattern: /\btwo[\s-]*year/gi, years: 2 },
                { pattern: /\bfour[\s-]*year/gi, years: 4 },
                { pattern: /\bsix[\s-]*year/gi, years: 6 },
                
                // Numeric year patterns
                { pattern: /\b(\d+)[\s-]*year/gi, numeric: true },
                { pattern: /\b(\d+)[\s-]*yr/gi, numeric: true },
                
                // Month patterns that equal years
                { pattern: /\bthirty[\s-]*six[\s-]*month/gi, years: 3 },
                { pattern: /\b36[\s-]*month/gi, years: 3 },
                { pattern: /\btwenty[\s-]*four[\s-]*month/gi, years: 2 },
                { pattern: /\b24[\s-]*month/gi, years: 2 },
                { pattern: /\btwelve[\s-]*month/gi, years: 1 },
                { pattern: /\b12[\s-]*month/gi, years: 1 },
                
                // Term language
                { pattern: /\binitial[\s]+term[\s]+of[\s]+(\d+)[\s]*year/gi, numeric: true },
                { pattern: /\bterm[\s]+of[\s]+(\d+)[\s]*year/gi, numeric: true },
                { pattern: /\b(\d+)[\s]*year[\s]*initial[\s]*term/gi, numeric: true }
            ];
            
            // Check each pattern
            for (const { pattern, years: fixedYears, numeric } of termPatterns) {
                const matches = [...summaryLower.matchAll(pattern)];
                if (matches.length > 0) {
                    if (numeric && matches[0][1]) {
                        years = parseInt(matches[0][1]);
                        console.log(`Found numeric term: ${matches[0][0]} = ${years} years`);
                    } else if (fixedYears) {
                        years = fixedYears;
                        console.log(`Found term: ${matches[0][0]} = ${years} years`);
                    }
                    break;
                }
            }
            
            // Calculate renewal date
            if (years > 0) {
                console.log(`Calculating ${years} years from ${effectiveDate}`);
                const endDate = calculateEndDate(effectiveDate, years);
                const formattedDate = formatDateForInput(endDate);
                console.log(`Calculated renewal date: ${formattedDate}`);
                return formattedDate;
            }
            
            console.log('No recognizable term found in summary. Searched for patterns like "three year", "3 year", "36 month", etc.');
            return null;
        }
        
        function cleanServiceCategory(description) {
            // If it's already short (2-4 words), return as is
            if (!description || description.split(' ').length <= 4) {
                // Check if it looks like a sentence (contains "provides", "offers", etc.)
                if (description && (description.includes('provides') || description.includes('offers') || description.includes('services'))) {
                    // Try to extract the key service type
                    if (description.toLowerCase().includes('waste') && description.toLowerCase().includes('recycl')) {
                        return 'Waste Management';
                    } else if (description.toLowerCase().includes('medical') || description.toLowerCase().includes('healthcare')) {
                        return 'Medical Supplies';
                    } else if (description.toLowerCase().includes('food') || description.toLowerCase().includes('dietary')) {
                        return 'Food Services';
                    } else if (description.toLowerCase().includes('clean')) {
                        return 'Cleaning Services';
                    } else if (description.toLowerCase().includes('it ') || description.toLowerCase().includes('technology')) {
                        return 'IT Services';
                    } else if (description.toLowerCase().includes('security')) {
                        return 'Security Services';
                    } else if (description.toLowerCase().includes('maintenance') || description.toLowerCase().includes('repair')) {
                        return 'Building Maintenance';
                    } else if (description.toLowerCase().includes('transport')) {
                        return 'Transportation Services';
                    } else if (description.toLowerCase().includes('lab')) {
                        return 'Laboratory Services';
                    } else if (description.toLowerCase().includes('equipment')) {
                        return 'Equipment Services';
                    } else {
                        // Try to extract the first 2-3 meaningful words
                        const words = description.replace(/provides|offers|services|including|and|the|for/gi, '').trim().split(' ');
                        return words.slice(0, 2).join(' ') + (words[1] ? '' : ' Services');
                    }
                }
                return description;
            }
            
            // If it's a long sentence, try to extract the service type
            const lowerDesc = description.toLowerCase();
            
            // Look for common patterns
            if (lowerDesc.includes('waste') && (lowerDesc.includes('management') || lowerDesc.includes('recycling'))) {
                return 'Waste Management';
            } else if (lowerDesc.includes('medical') || lowerDesc.includes('healthcare')) {
                return 'Medical Supplies';
            } else if (lowerDesc.includes('food') || lowerDesc.includes('dietary')) {
                return 'Food Services';
            } else if (lowerDesc.includes('cleaning') || lowerDesc.includes('janitorial')) {
                return 'Cleaning Services';
            } else if (lowerDesc.includes('information technology') || lowerDesc.includes('it ')) {
                return 'IT Services';
            } else {
                // Extract the first 2-3 meaningful words
                const words = description.replace(/provides|offers|services|including|and|the|for|company|vendor/gi, '').trim().split(' ');
                const serviceWords = words.filter(w => w.length > 2).slice(0, 2);
                return serviceWords.join(' ') + (serviceWords.length === 1 ? ' Services' : '');
            }
        }

        function parseAIResponse(content) {
            console.log('Raw AI response:', content);
            
            try {
                // Try to parse JSON directly
                const parsed = JSON.parse(content);
                console.log('Successfully parsed JSON:', parsed);
                
                // Clean up business_description if it's a sentence
                if (parsed.business_description) {
                    parsed.business_description = cleanServiceCategory(parsed.business_description);
                }
                
                // Validate date consistency
                if (parsed.effective_date && parsed.reconciliation_summary) {
                    const effectiveDateFormatted = formatDateForSummary(parsed.effective_date);
                    if (!parsed.reconciliation_summary.includes(effectiveDateFormatted)) {
                        console.warn('Date inconsistency detected - fixing summary to match effective date');
                        // Try to fix the summary by replacing any wrong dates with the correct one
                        parsed.reconciliation_summary = fixDateInSummary(parsed.reconciliation_summary, parsed.effective_date);
                    }
                }
                
                // Extract dates from summary if AI didn't extract them properly
                if (parsed.reconciliation_summary) {
                    const extractedDates = extractDatesFromSummary(parsed.reconciliation_summary);
                    
                    // Fix effective date if it's wrong (like today's date instead of contract date)
                    if (extractedDates.effectiveDate && 
                        (!parsed.effective_date || parsed.effective_date === getTodayForInput())) {
                        parsed.effective_date = extractedDates.effectiveDate;
                        console.log('Corrected effective date from summary:', parsed.effective_date);
                    }
                    
                    // Calculate renewal date if not provided but term is mentioned
                    if (parsed.effective_date && !parsed.renewal_date) {
                        parsed.renewal_date = calculateRenewalDate(parsed.effective_date, parsed.reconciliation_summary);
                        if (parsed.renewal_date) {
                            console.log('Calculated renewal date from term:', parsed.renewal_date);
                        }
                    }
                }
                
                return parsed;
            } catch (e) {
                console.log('Direct parse failed, attempting extraction...');
                
                // Try multiple regex patterns to find JSON
                const patterns = [
                    /\{[\s\S]*\}/,  // Standard JSON object
                    /```json\s*([\s\S]*?)```/,  // Markdown code block
                    /```\s*([\s\S]*?)```/,  // Generic code block
                ];
                
                for (const pattern of patterns) {
                    const match = content.match(pattern);
                    if (match) {
                        const jsonStr = match[1] || match[0];
                        try {
                            // Clean common issues
                            let cleaned = jsonStr
                                .trim()
                                .replace(/^```json\s*/g, '')
                                .replace(/```$/g, '')
                                .replace(/,\s*([}\]])/g, '$1')  // Remove trailing commas
                                .replace(/(['"])?([a-zA-Z0-9_]+)(['"])?\s*:/g, '"$2":')  // Fix unquoted keys
                                .replace(/'/g, '"')  // Replace single quotes
                                .replace(/[\u201C\u201D]/g, '"')  // Fix smart quotes
                                .replace(/\n/g, ' ')  // Remove newlines in strings
                                .replace(/\t/g, ' ');  // Remove tabs
                            
                            console.log('Attempting to parse cleaned JSON:', cleaned.substring(0, 200));
                            const parsed = JSON.parse(cleaned);
                            console.log('Successfully parsed after cleaning:', parsed);
                            
                            // Clean up business_description if it's a sentence
                            if (parsed.business_description) {
                                parsed.business_description = cleanServiceCategory(parsed.business_description);
                            }
                            
                            // Extract dates from summary if AI didn't extract them properly
                            if (parsed.reconciliation_summary) {
                                const extractedDates = extractDatesFromSummary(parsed.reconciliation_summary);
                                
                                // Fix effective date if it's wrong
                                if (extractedDates.effectiveDate && 
                                    (!parsed.effective_date || parsed.effective_date === getTodayForInput())) {
                                    parsed.effective_date = extractedDates.effectiveDate;
                                    console.log('Corrected effective date from cleaned summary:', parsed.effective_date);
                                }
                                
                                // Calculate renewal date if not provided but term is mentioned
                                if (parsed.effective_date && !parsed.renewal_date) {
                                    parsed.renewal_date = calculateRenewalDate(parsed.effective_date, parsed.reconciliation_summary);
                                    if (parsed.renewal_date) {
                                        console.log('Calculated renewal date from cleaned response:', parsed.renewal_date);
                                    }
                                }
                            }
                            
                            return parsed;
                        } catch (parseError) {
                            console.log('Parse attempt failed:', parseError.message);
                        }
                    }
                }
                
                // If all else fails, try to construct from keywords
                console.log('All parsing attempts failed, using fallback');
                const vendorMatch = content.match(/vendor[_\s]?name["']?\s*:\s*["']([^"']+)["']/i);
                const descMatch = content.match(/business[_\s]?description["']?\s*:\s*["']([^"']+)["']/i);
                const summaryMatch = content.match(/reconciliation[_\s]?summary["']?\s*:\s*["']([^"']+)["']/i);
                
                const fallbackSummary = summaryMatch ? summaryMatch[1] : "Unable to extract contract terms. Please review the contract manually.";
                const fallbackResult = {
                    vendor_name: vendorMatch ? vendorMatch[1] : "Unknown Vendor",
                    business_description: descMatch ? cleanServiceCategory(descMatch[1]) : "General Services",
                    effective_date: null,
                    renewal_date: null,
                    reconciliation_summary: fallbackSummary
                };
                
                // Try to extract dates from summary even in fallback
                if (fallbackSummary && fallbackSummary !== "Unable to extract contract terms. Please review the contract manually.") {
                    const extractedDates = extractDatesFromSummary(fallbackSummary);
                    if (extractedDates.effectiveDate) {
                        fallbackResult.effective_date = extractedDates.effectiveDate;
                        fallbackResult.renewal_date = calculateRenewalDate(extractedDates.effectiveDate, fallbackSummary);
                        console.log('Extracted dates from fallback summary:', fallbackResult);
                    }
                }
                
                return fallbackResult;
            }
        }

        function showAIInsights(analysis) {
            const container = document.getElementById('insightsContainer');
            
            let insightsHtml = `
                <div class="insight-section">
                    <h4 style="color: var(--accent-cyan); margin-bottom: 15px;">üìã Contract Analysis</h4>
                    ${analysis.vendor_name ? `
                        <div class="insight-item">
                            <div class="insight-label">Vendor Name</div>
                            <div class="insight-value">${analysis.vendor_name}</div>
                        </div>
                    ` : ''}
                    ${analysis.business_description ? `
                        <div class="insight-item">
                            <div class="insight-label">Service Category</div>
                            <div class="insight-value">${analysis.business_description}</div>
                        </div>
                    ` : ''}
                    ${analysis.effective_date ? `
                        <div class="insight-item">
                            <div class="insight-label">Contract Effective Date</div>
                            <div class="insight-value">${formatDateForDisplay(analysis.effective_date)}</div>
                        </div>
                    ` : ''}
                    ${analysis.renewal_date ? `
                        <div class="insight-item">
                            <div class="insight-label">Contract End/Renewal Date</div>
                            <div class="insight-value">${formatDateForDisplay(analysis.renewal_date)}</div>
                        </div>
                    ` : ''}
                    <div class="insight-item">
                        <div class="insight-label">Date Added to System</div>
                        <div class="insight-value">${getTodayFormatted()}</div>
                    </div>
                    ${analysis.reconciliation_summary ? `
                        <div class="insight-item">
                            <div class="insight-label">Invoice Reconciliation Terms</div>
                            <div class="insight-value" style="line-height: 1.6; white-space: pre-wrap;">${analysis.reconciliation_summary}</div>
                        </div>
                    ` : ''}
                </div>
            `;
            
            container.innerHTML = insightsHtml;
        }

        function prefillVendorForm(analysis) {
            console.log('Prefilling form with analysis:', analysis);
            
            // Pre-fill vendor name from simplified structure
            if (analysis.vendor_name) {
                document.getElementById('vendorName').value = analysis.vendor_name;
                console.log('Set vendor name to:', analysis.vendor_name);
            }
            
            // Pre-fill business description
            if (analysis.business_description) {
                document.getElementById('businessDescription').value = analysis.business_description;
                console.log('Set business description to:', analysis.business_description);
            }
            
            // Add reconciliation summary to notes field
            if (analysis.reconciliation_summary) {
                document.getElementById('notes').value = analysis.reconciliation_summary;
                console.log('Set notes to reconciliation summary');
            }
            
            // Pre-fill dates if found in contract
            if (analysis.effective_date) {
                // Try to parse and format the date
                const effectiveDate = parseContractDate(analysis.effective_date);
                if (effectiveDate) {
                    document.getElementById('effectiveDate').value = effectiveDate;
                    console.log('Set effective date to:', effectiveDate);
                }
            } else {
                // Set today's date as default if not found
                document.getElementById('effectiveDate').value = getTodayForInput();
            }
            
            if (analysis.renewal_date) {
                const renewalDate = parseContractDate(analysis.renewal_date);
                if (renewalDate) {
                    document.getElementById('renewalDate').value = renewalDate;
                    console.log('Set renewal date to:', renewalDate);
                }
            }
            
            // Always set upload date to today
            document.getElementById('uploadDate').value = getTodayForInput();
            
            // Setup real-time validation and load any draft
            setupFormValidation();
            loadDraft();
        }
        
        function setupFormValidation() {
            const form = document.getElementById('addVendorForm');
            const inputs = form.querySelectorAll('input, textarea');
            
            inputs.forEach(input => {
                input.addEventListener('blur', () => validateField(input));
                input.addEventListener('input', () => {
                    clearFieldError(input);
                    saveDraft(); // Auto-save on input
                });
            });
        }
        
        function validateField(field) {
            const value = field.value.trim();
            const isRequired = field.hasAttribute('required');
            
            clearFieldError(field);
            
            if (isRequired && !value) {
                showFieldError(field, 'This field is required');
                return false;
            }
            
            if (field.type === 'date' && value) {
                const date = new Date(value);
                const today = new Date();
                const oneYearAgo = new Date(today.getFullYear() - 10, today.getMonth(), today.getDate());
                const oneYearFromNow = new Date(today.getFullYear() + 10, today.getMonth(), today.getDate());
                
                if (date < oneYearAgo || date > oneYearFromNow) {
                    showFieldError(field, 'Please enter a reasonable contract date');
                    return false;
                }
            }
            
            return true;
        }
        
        function showFieldError(field, message) {
            field.style.borderColor = 'var(--error)';
            let errorDiv = field.parentNode.querySelector('.field-error');
            if (!errorDiv) {
                errorDiv = document.createElement('div');
                errorDiv.className = 'field-error';
                errorDiv.style.color = 'var(--error)';
                errorDiv.style.fontSize = '12px';
                errorDiv.style.marginTop = '4px';
                field.parentNode.appendChild(errorDiv);
            }
            errorDiv.textContent = message;
        }
        
        function clearFieldError(field) {
            field.style.borderColor = '';
            const errorDiv = field.parentNode.querySelector('.field-error');
            if (errorDiv) {
                errorDiv.remove();
            }
        }

        async function saveVendor() {
            const form = document.getElementById('addVendorForm');
            const formData = new FormData(form);
            
            // Validate required fields
            const name = formData.get('vendorName').trim();
            const businessDescription = formData.get('businessDescription').trim();
            const reconciliationTerms = formData.get('notes').trim();
            const effectiveDate = formData.get('effectiveDate');
            const renewalDate = formData.get('renewalDate');
            const uploadDate = formData.get('uploadDate') || getTodayForInput();
            
            if (!name || !businessDescription || !reconciliationTerms || !effectiveDate) {
                showToast('Please fill in all required fields', 'error');
                return;
            }
            
            if (!uploadedFile || !contractAnalysis) {
                showToast('Contract analysis not completed', 'error');
                return;
            }
            
            try {
                // Create FormData for backend API
                const apiFormData = new FormData();
                apiFormData.append('vendor_name', name);
                apiFormData.append('business_description', businessDescription);
                apiFormData.append('reconciliation_summary', reconciliationTerms);
                apiFormData.append('effective_date', effectiveDate);
                apiFormData.append('renewal_date', renewalDate || '');
                apiFormData.append('contract_file', uploadedFile);
                
                showToast('Saving vendor to server...', 'info');
                
                // Check if backend is available, fallback to localStorage if not
                try {
                    const response = await fetch('/api/vendors', {
                        method: 'POST',
                        body: apiFormData
                    });
                    
                    if (response.ok) {
                        const result = await response.json();
                        console.log('Vendor saved to backend:', result);
                        
                        // Also save to localStorage for compatibility
                        const vendor = {
                            id: result.vendor_id,
                            vendor_name: name,
                            business_description: businessDescription,
                            effective_date: effectiveDate,
                            renewal_date: renewalDate || null,
                            upload_date: uploadDate,
                            reconciliation_summary: reconciliationTerms,
                            status: 'active',
                            created_at: new Date().toISOString(),
                            contract_file_path: `/api/vendors/${result.vendor_id}/contract`,
                            contractFile: uploadedFile.name,
                            // Add backend URL for contract viewing
                            contract_url: `/api/vendors/${result.vendor_id}/contract`
                        };
                        
                        const existingVendors = JSON.parse(localStorage.getItem('vendors') || '[]');
                        existingVendors.push(vendor);
                        localStorage.setItem('vendors', JSON.stringify(existingVendors));
                        
                        clearDraft();
                        showToast('Vendor profile created successfully!', 'success');
                        
                        setTimeout(() => {
                            window.location.href = 'index.html';
                        }, 1500);
                        
                        return;
                    } else {
                        console.warn('Backend unavailable, falling back to localStorage');
                        throw new Error('Backend not available');
                    }
                } catch (backendError) {
                    console.warn('Backend error, using localStorage fallback:', backendError);
                    
                    // Fallback to localStorage storage
                    const vendor = {
                        id: Date.now().toString(),
                        name: name,
                        vendor_name: name,
                        business_description: businessDescription,
                        effective_date: effectiveDate,
                        renewal_date: renewalDate || null,
                        upload_date: uploadDate,
                        contract_date: effectiveDate,
                        reconciliation_summary: reconciliationTerms,
                        ai_extracted_name: contractAnalysis.vendor_name || '',
                        ai_extracted_description: contractAnalysis.business_description || '',
                        ai_extracted_summary: contractAnalysis.reconciliation_summary || '',
                        contractFileData: await fileToBase64(uploadedFile),
                        contractFile: uploadedFile.name,
                        status: 'active',
                        created_at: new Date().toISOString(),
                        invoice_count: 0
                    };
                    
                    const existingVendors = JSON.parse(localStorage.getItem('vendors') || '[]');
                    const duplicate = existingVendors.find(v => 
                        v.vendor_name?.toLowerCase() === name.toLowerCase() || 
                        v.name?.toLowerCase() === name.toLowerCase()
                    );
                    
                    if (duplicate) {
                        const confirmed = confirm(`A vendor named "${name}" already exists. Do you want to create it anyway?`);
                        if (!confirmed) {
                            return;
                        }
                    }
                    
                    existingVendors.push(vendor);
                    localStorage.setItem('vendors', JSON.stringify(existingVendors));
                    
                    console.log('Vendor saved to localStorage:', vendor);
                    clearDraft();
                    showToast('Vendor profile created successfully (offline mode)!', 'success');
                    
                    setTimeout(() => {
                        window.location.href = 'index.html';
                    }, 1500);
                }
                
            } catch (error) {
                console.error('Error saving vendor:', error);
                
                // Enhanced error recovery
                if (error.message.includes('storage')) {
                    showToast('Storage error. Please try again or clear browser data.', 'error');
                } else if (error.message.includes('duplicate')) {
                    showToast('This vendor name already exists. Please use a different name.', 'error');
                } else {
                    showToast('Error saving vendor: ' + error.message + '. Please try again.', 'error');
                }
                
                // Keep form data for retry
                saveDraft();
            }
        }

        function fileToBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.readAsDataURL(file);
                reader.onload = () => resolve(reader.result);
                reader.onerror = error => reject(error);
            });
        }
    </script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Add New Vendor - Contract Reconciliation Platform</title>
    <style>
        :root {
            --primary: #0f0f0f;
            --secondary: #1a1a1a;
            --accent: #2a2a2a;
            --border: #333;
            --text: #ffffff;
            --text-muted: #b0b0b0;
            --accent-cyan: #00d4ff;
            --accent-purple: #8b5cf6;
            --accent-success: #10b981;
            --accent-warning: #f59e0b;
            --accent-error: #ef4444;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            color: var(--text);
            min-height: 100vh;
            line-height: 1.6;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 40px 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            background: linear-gradient(135deg, var(--accent-cyan), var(--accent-purple));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .header p {
            color: var(--text-muted);
            font-size: 1.1rem;
        }

        .back-button {
            position: absolute;
            top: 30px;
            left: 30px;
            background: var(--secondary);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 10px 20px;
            border-radius: 8px;
            text-decoration: none;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.2s ease;
        }

        .back-button:hover {
            background: var(--accent);
            border-color: var(--accent-cyan);
        }

        .upload-section {
            background: var(--secondary);
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 40px;
            margin-bottom: 30px;
            text-align: center;
        }

        .upload-area {
            border: 2px dashed var(--border);
            border-radius: 12px;
            padding: 60px 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .upload-area:hover {
            border-color: var(--accent-cyan);
            background: rgba(0, 212, 255, 0.05);
        }

        .upload-area.drag-over {
            border-color: var(--accent-cyan);
            background: rgba(0, 212, 255, 0.1);
        }

        .upload-icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 20px;
            opacity: 0.6;
        }

        .upload-text {
            font-size: 1.3rem;
            margin-bottom: 10px;
            font-weight: 600;
        }

        .upload-subtext {
            color: var(--text-muted);
            margin-bottom: 20px;
        }

        .file-types {
            color: var(--text-muted);
            font-size: 0.9rem;
        }

        .processing-section {
            background: var(--secondary);
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 40px;
            margin-bottom: 30px;
            display: none;
        }

        .processing-title {
            text-align: center;
            margin-bottom: 30px;
            font-size: 1.5rem;
        }

        .progress-container {
            margin-bottom: 30px;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: var(--accent);
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 10px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent-cyan), var(--accent-purple));
            width: 0%;
            transition: width 0.3s ease;
        }

        .progress-text {
            color: var(--text-muted);
            text-align: center;
        }

        .vendor-form {
            background: var(--secondary);
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 40px;
            display: none;
        }

        .form-group {
            margin-bottom: 24px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: var(--text);
        }

        .form-group input,
        .form-group textarea {
            width: 100%;
            padding: 12px 16px;
            background: var(--primary);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text);
            font-size: 16px;
            transition: border-color 0.2s ease;
        }

        .form-group input:focus,
        .form-group textarea:focus {
            outline: none;
            border-color: var(--accent-cyan);
        }

        .form-group textarea {
            resize: vertical;
            min-height: 100px;
        }

        .required {
            color: var(--accent-error);
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            transition: all 0.2s ease;
            font-size: 16px;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--accent-cyan), var(--accent-purple));
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 212, 255, 0.3);
        }

        .btn-secondary {
            background: var(--accent);
            color: var(--text);
            border: 1px solid var(--border);
        }

        .btn-secondary:hover {
            background: var(--primary);
            border-color: var(--accent-cyan);
        }

        .form-actions {
            display: flex;
            gap: 16px;
            justify-content: center;
            margin-top: 30px;
        }

        .ai-insights {
            background: rgba(0, 212, 255, 0.1);
            border: 1px solid var(--accent-cyan);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 30px;
            display: none;
        }

        .ai-insights-title {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
            color: var(--accent-cyan);
            font-weight: 600;
        }

        .insight-item {
            background: var(--primary);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 10px;
        }

        .insight-label {
            font-weight: 600;
            color: var(--accent-cyan);
            margin-bottom: 4px;
        }

        .insight-value {
            color: var(--text-muted);
        }

        .toast-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 10000;
        }
        
        .toast {
            background: var(--secondary);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 16px 20px;
            margin-bottom: 10px;
            min-width: 300px;
            display: flex;
            align-items: center;
            gap: 12px;
            animation: slideIn 0.3s ease-out;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        
        .toast.success {
            border-left: 4px solid var(--accent-success);
        }
        
        .toast.error {
            border-left: 4px solid var(--accent-error);
        }
        
        .toast.warning {
            border-left: 4px solid var(--accent-warning);
        }
        
        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        @keyframes slideOut {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(100%);
                opacity: 0;
            }
        }
    </style>
    <!-- External Libraries -->
    <script src='https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js'></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    </script>
</head>
<body>
    <!-- Toast Container -->
    <div class="toast-container" id="toastContainer"></div>

    <a href="index.html" class="back-button">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M19 12H5M12 19l-7-7 7-7"/>
        </svg>
        Back to Dashboard
    </a>

    <div class="container">
        <div class="header">
            <h1>Add New Vendor</h1>
            <p>Upload a contract to automatically create a vendor profile</p>
        </div>

        <!-- Upload Section -->
        <div class="upload-section" id="uploadSection">
            <div class="upload-area" id="uploadArea" onclick="document.getElementById('contractFile').click()">
                <input type="file" id="contractFile" accept=".pdf,.doc,.docx,.jpg,.jpeg,.png,.tiff,.bmp" style="display: none;" onchange="handleFileSelect(event)">
                
                <svg class="upload-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                    <polyline points="14 2 14 8 20 8"></polyline>
                    <line x1="12" y1="11" x2="12" y2="17"></line>
                    <polyline points="9 14 12 11 15 14"></polyline>
                </svg>
                
                <div class="upload-text">Upload Contract Document</div>
                <div class="upload-subtext">Drag and drop your contract file or click to browse</div>
                <div class="file-types">Supports PDF, Word documents, and images</div>
            </div>
        </div>

        <!-- Processing Section -->
        <div class="processing-section" id="processingSection">
            <div class="processing-title">🤖 AI Analysis in Progress</div>
            <div class="processing-subtitle" id="processingSubtitle" style="text-align: center; color: var(--text-muted); margin-bottom: 20px; display: none;">
                Using GPT-4 Vision to analyze tables, charts, and structured content
            </div>
            <div class="progress-container">
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <div class="progress-text" id="progressText">Extracting text from contract...</div>
            </div>
        </div>

        <!-- AI Insights Section -->
        <div class="ai-insights" id="aiInsights">
            <div class="ai-insights-title">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="3"></circle>
                    <path d="M12 1v6m0 6v6m11-7h-6m-6 0H1"></path>
                </svg>
                AI Contract Insights
            </div>
            <div id="insightsContainer"></div>
        </div>

        <!-- Vendor Form -->
        <div class="vendor-form" id="vendorForm">
            <h2 style="margin-bottom: 30px; text-align: center;">Confirm Vendor Information</h2>
            <p style="text-align: center; color: var(--text-muted); margin-bottom: 30px;">
                Review the AI-extracted information and add any missing details
            </p>
            
            <form id="addVendorForm">
                <div class="form-group">
                    <label for="vendorName">Vendor Name <span class="required">*</span></label>
                    <input type="text" id="vendorName" name="vendorName" required>
                </div>
                
                <div class="form-group">
                    <label for="businessDescription">Service Category <span class="required">*</span></label>
                    <input type="text" id="businessDescription" name="businessDescription" placeholder="e.g., Waste Management, Medical Supplies, Food Services, Building Maintenance" required>
                </div>
                
                <div class="form-group">
                    <label for="effectiveDate">Contract Effective Date <span class="required">*</span></label>
                    <input type="date" id="effectiveDate" name="effectiveDate" required>
                </div>
                
                <div class="form-group">
                    <label for="renewalDate">Contract End/Renewal Date</label>
                    <input type="date" id="renewalDate" name="renewalDate">
                </div>
                
                <div class="form-group">
                    <label for="uploadDate">Date Added to System</label>
                    <input type="date" id="uploadDate" name="uploadDate" readonly style="background-color: rgba(255, 255, 255, 0.05); cursor: not-allowed;">
                </div>
                
                <div class="form-group">
                    <label for="notes">Invoice Reconciliation Terms <span class="required">*</span></label>
                    <textarea id="notes" name="notes" placeholder="Key terms for invoice reconciliation" rows="5" required></textarea>
                </div>
            </form>
            
            <div class="form-actions">
                <button type="button" class="btn btn-secondary" onclick="window.location.href='index.html'">Cancel</button>
                <button type="button" class="btn btn-primary" onclick="saveVendor()">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="20 6 9 17 4 12"></polyline>
                    </svg>
                    Create Vendor Profile
                </button>
            </div>
        </div>
    </div>

    <script>
        let uploadedFile = null;
        let contractAnalysis = null;
        let apiKey = localStorage.getItem('openai_api_key');
        let currentAnalysisController = null; // For cancellation

        // Toast notification system
        function showToast(message, type = 'info', duration = 5000) {
            const toastContainer = document.getElementById('toastContainer');
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            
            const icon = type === 'success' ? '✅' : type === 'error' ? '❌' : type === 'warning' ? '⚠️' : 'ℹ️';
            toast.innerHTML = `<span>${icon}</span><span>${message}</span>`;
            
            toastContainer.appendChild(toast);
            
            setTimeout(() => {
                toast.style.animation = 'slideOut 0.3s ease-in';
                setTimeout(() => toast.remove(), 300);
            }, duration);
        }

        // Drag and drop functionality
        document.addEventListener('DOMContentLoaded', function() {
            const uploadArea = document.getElementById('uploadArea');
            
            uploadArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadArea.classList.add('drag-over');
            });

            uploadArea.addEventListener('dragleave', () => {
                uploadArea.classList.remove('drag-over');
            });

            uploadArea.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadArea.classList.remove('drag-over');
                const files = Array.from(e.dataTransfer.files);
                if (files.length > 0) {
                    const file = files[0];
                    const errors = validateFile(file);
                    if (errors.length === 0) {
                        handleFileUpload(file);
                    } else {
                        showToast(errors.join(' '), 'error');
                    }
                }
            });

            // Check for API key
            if (!apiKey) {
                showToast('OpenAI API key not found. Please go to the main dashboard and set your API key in Settings.', 'warning');
                console.error('OpenAI API key not found in localStorage');
            } else {
                console.log('OpenAI API key found, ready to process contracts');
            }
        });

        function isValidFileType(file) {
            const validTypes = [
                'application/pdf',
                'application/msword',
                'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
                'image/jpeg',
                'image/jpg',
                'image/png',
                'image/tiff',
                'image/bmp'
            ];
            return validTypes.includes(file.type);
        }
        
        function validateFile(file) {
            const maxSize = 50 * 1024 * 1024; // 50MB limit
            const errors = [];
            
            if (!isValidFileType(file)) {
                errors.push(`File type "${file.type || 'unknown'}" is not supported. Please use PDF, Word, or image files.`);
            }
            
            if (file.size > maxSize) {
                errors.push(`File size (${(file.size / (1024 * 1024)).toFixed(1)}MB) exceeds the 50MB limit.`);
            }
            
            if (file.size === 0) {
                errors.push('File appears to be empty or corrupted.');
            }
            
            return errors;
        }

        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (file) {
                const errors = validateFile(file);
                if (errors.length === 0) {
                    handleFileUpload(file);
                } else {
                    showToast(errors.join(' '), 'error');
                }
            }
        }

        async function handleFileUpload(file) {
            if (!apiKey) {
                showToast('OpenAI API key required. Please set it in the main dashboard Settings.', 'error');
                return;
            }
            
            console.log('Processing file:', file.name, 'Type:', file.type, 'Size:', file.size);

            uploadedFile = file;
            
            // Show file preview
            showFilePreview(file);
            
            // Hide upload section, show processing
            document.getElementById('uploadSection').style.display = 'none';
            document.getElementById('processingSection').style.display = 'block';
            
            console.log(`Processing contract: ${file.name}`);
            
            try {
                // Step 1: Determine analysis method
                if (file.type.startsWith('image/')) {
                    updateProgress('Preparing for AI Vision analysis...', 10);
                } else if (file.type === 'application/pdf') {
                    updateProgress('Converting PDF pages for Vision analysis...', 10);
                } else {
                    updateProgress('Extracting text from contract...', 20);
                }
                
                // Step 2: Extract text (for fallback if needed)
                const contractText = await extractTextFromFile(file);
                
                // Step 3: Analyze with enhanced AI (Vision or Text)
                updateProgress('Analyzing contract with enhanced AI...', 50);
                contractAnalysis = await analyzeContract(contractText);
                
                console.log('Contract analysis result:', contractAnalysis);
                
                if (!contractAnalysis || !contractAnalysis.vendor_name) {
                    throw new Error('AI analysis did not extract vendor name');
                }
                
                // Step 3: Show insights
                updateProgress('Extracting vendor information...', 80);
                showAIInsights(contractAnalysis);
                
                // Step 4: Pre-fill form
                updateProgress('Preparing vendor form...', 100);
                prefillVendorForm(contractAnalysis);
                
                // Show final sections
                setTimeout(() => {
                    document.getElementById('processingSection').style.display = 'none';
                    document.getElementById('aiInsights').style.display = 'block';
                    document.getElementById('vendorForm').style.display = 'block';
                    console.log('Contract analysis complete! Review and complete the vendor profile.');
                }, 1000);
                
            } catch (error) {
                console.error('Error processing contract:', error);
                showToast(`Contract processing failed: ${error.message}`, 'error');
                document.getElementById('processingSection').style.display = 'none';
                document.getElementById('uploadSection').style.display = 'block';
                
                // Reset state
                uploadedFile = null;
                contractAnalysis = null;
            }
        }

        function updateProgress(message, percentage) {
            document.getElementById('progressFill').style.width = percentage + '%';
            document.getElementById('progressText').textContent = message;
            
            // Add cancel button during processing
            const progressContainer = document.querySelector('.progress-container');
            let cancelBtn = progressContainer.querySelector('.cancel-btn');
            
            if (percentage > 0 && percentage < 100 && !cancelBtn) {
                cancelBtn = document.createElement('button');
                cancelBtn.className = 'cancel-btn';
                cancelBtn.innerHTML = '✕ Cancel';
                cancelBtn.style.cssText = 'margin-top: 10px; padding: 8px 16px; background: var(--error); color: white; border: none; border-radius: 4px; cursor: pointer;';
                cancelBtn.onclick = cancelAnalysis;
                progressContainer.appendChild(cancelBtn);
            } else if (percentage >= 100 && cancelBtn) {
                cancelBtn.remove();
            }
        }
        
        function cancelAnalysis() {
            if (currentAnalysisController) {
                currentAnalysisController.abort();
            }
            
            // Reset UI
            document.getElementById('uploadSection').style.display = 'block';
            document.getElementById('processingSection').style.display = 'none';
            document.getElementById('aiInsights').style.display = 'none';
            document.getElementById('vendorForm').style.display = 'none';
            
            // Clear state
            uploadedFile = null;
            contractAnalysis = null;
            currentAnalysisController = null;
            
            showToast('Analysis cancelled', 'info');
        }
        
        function showFilePreview(file) {
            const processingSection = document.getElementById('processingSection');
            let previewDiv = processingSection.querySelector('.file-preview');
            
            if (!previewDiv) {
                previewDiv = document.createElement('div');
                previewDiv.className = 'file-preview';
                previewDiv.style.cssText = 'margin-bottom: 20px; padding: 15px; background: rgba(30, 41, 59, 0.5); border-radius: 8px; border: 1px solid var(--border);';
                processingSection.insertBefore(previewDiv, processingSection.firstChild);
            }
            
            const fileSize = (file.size / (1024 * 1024)).toFixed(1);
            const fileIcon = getFileIcon(file.type);
            
            previewDiv.innerHTML = `
                <div style="display: flex; align-items: center; gap: 12px;">
                    <div style="font-size: 24px;">${fileIcon}</div>
                    <div>
                        <div style="font-weight: 500; color: var(--text-primary);">${file.name}</div>
                        <div style="font-size: 12px; color: var(--text-secondary);">${file.type} • ${fileSize}MB</div>
                    </div>
                </div>
            `;
        }
        
        function getFileIcon(fileType) {
            if (fileType === 'application/pdf') return '📄';
            if (fileType.startsWith('image/')) return '🖼️';
            if (fileType.includes('word')) return '📄';
            return '📁';
        }
        
        let draftSaveTimeout;
        function saveDraft() {
            clearTimeout(draftSaveTimeout);
            draftSaveTimeout = setTimeout(() => {
                const form = document.getElementById('addVendorForm');
                if (!form) return;
                
                const formData = new FormData(form);
                const draft = {
                    vendorName: formData.get('vendorName') || '',
                    businessDescription: formData.get('businessDescription') || '',
                    effectiveDate: formData.get('effectiveDate') || '',
                    renewalDate: formData.get('renewalDate') || '',
                    uploadDate: formData.get('uploadDate') || new Date().toISOString().split('T')[0],
                    notes: formData.get('notes') || '',
                    timestamp: Date.now()
                };
                
                localStorage.setItem('vendor_draft', JSON.stringify(draft));
                
                // Show brief save indicator
                showSaveIndicator();
            }, 1000);
        }
        
        function loadDraft() {
            const draft = localStorage.getItem('vendor_draft');
            if (!draft) return;
            
            try {
                const draftData = JSON.parse(draft);
                const age = Date.now() - draftData.timestamp;
                
                // Only load drafts less than 24 hours old
                if (age < 24 * 60 * 60 * 1000) {
                    document.getElementById('vendorName').value = draftData.vendorName || '';
                    document.getElementById('businessDescription').value = draftData.businessDescription || '';
                    document.getElementById('effectiveDate').value = draftData.effectiveDate || draftData.contractDate || '';
                    document.getElementById('renewalDate').value = draftData.renewalDate || '';
                    document.getElementById('uploadDate').value = draftData.uploadDate || new Date().toISOString().split('T')[0];
                    document.getElementById('notes').value = draftData.notes || '';
                    
                    if (draftData.vendorName || draftData.businessDescription) {
                        showToast('Draft data restored', 'info');
                    }
                }
            } catch (e) {
                console.error('Error loading draft:', e);
            }
        }
        
        function clearDraft() {
            localStorage.removeItem('vendor_draft');
        }
        
        function showSaveIndicator() {
            let indicator = document.querySelector('.save-indicator');
            if (!indicator) {
                indicator = document.createElement('div');
                indicator.className = 'save-indicator';
                indicator.style.cssText = 'position: fixed; top: 20px; right: 20px; background: var(--success); color: white; padding: 8px 16px; border-radius: 4px; font-size: 12px; z-index: 1000; opacity: 0; transition: opacity 0.3s;';
                indicator.textContent = '✓ Draft saved';
                document.body.appendChild(indicator);
            }
            
            indicator.style.opacity = '1';
            setTimeout(() => {
                indicator.style.opacity = '0';
            }, 2000);
        }

        async function extractTextFromFile(file) {
            const fileType = file.type;
            
            if (fileType === 'application/pdf') {
                return await extractTextFromPDF(file);
            } else if (fileType.startsWith('image/')) {
                return await extractTextFromImage(file);
            } else if (fileType.includes('word')) {
                // For Word documents, we'll treat them as text for now
                showToast('Word document detected. For best results, please convert to PDF first.', 'warning');
                return await extractTextFromImage(file); // Fallback to OCR
            }
            
            throw new Error('Unsupported file type');
        }

        async function extractTextFromPDF(file) {
            const arrayBuffer = await file.arrayBuffer();
            const pdf = await pdfjsLib.getDocument(arrayBuffer).promise;
            let fullText = '';
            
            for (let i = 1; i <= pdf.numPages; i++) {
                const page = await pdf.getPage(i);
                const textContent = await page.getTextContent();
                const pageText = textContent.items.map(item => item.str).join(' ');
                fullText += pageText + '\\n';
            }
            
            return fullText;
        }

        async function extractTextFromImage(file) {
            const { data: { text } } = await Tesseract.recognize(file, 'eng', {
                logger: m => {
                    if (m.status === 'recognizing text') {
                        updateProgress(`OCR Processing: ${Math.round(m.progress * 100)}%`, 30 + (m.progress * 20));
                    }
                }
            });
            return text;
        }

        async function analyzeContract(text) {
            // First try GPT-4 Vision if we have the original file as an image
            if (uploadedFile && uploadedFile.type.startsWith('image/')) {
                return await analyzeContractWithVision(uploadedFile);
            }
            
            // For PDFs, convert to images and use vision
            if (uploadedFile && uploadedFile.type === 'application/pdf') {
                return await analyzeContractPDFWithVision(uploadedFile);
            }
            
            // Fallback to text analysis for other cases
            return await analyzeContractWithText(text);
        }

        async function analyzeContractWithVision(imageFile) {
            const prompt = `Carefully analyze this ENTIRE contract image. Look at ALL sections, tables, and lists.

Extract:
1. The vendor/supplier company name
2. IMPORTANT: Only provide a 2-3 word service category NAME (NOT a sentence). For example, if it's a waste/recycling company, just write "Waste Management". If it's a medical supply company, just write "Medical Supplies". Do NOT write full sentences like "provides waste and recycling services". Examples of correct format: "Waste Management", "Medical Supplies", "IT Services", "Building Maintenance", "Food Services", "Laboratory Testing", "Security Services", "Office Supplies", "Cleaning Services", "Equipment Rental"
3. The contract effective date (when the contract starts/began)
4. The contract renewal date or expiration date (if mentioned)
5. A comprehensive 3-5 sentence summary of ALL terms relevant for invoice reconciliation

Pay special attention to:
- Contract dates (effective date, start date, renewal date, expiration date)
- Tables showing pricing or fees
- Lists of services and costs
- Payment schedules
- ALL recurring charges
- Setup fees or one-time costs
- Payment terms and deadlines
- Special billing requirements

Return ONLY this JSON:
{
  "vendor_name": "[exact vendor name]",
  "business_description": "[ONLY 2-3 word category like 'Waste Management' - NOT a sentence]",
  "effective_date": "[YYYY-MM-DD format if found, or null]",
  "renewal_date": "[YYYY-MM-DD format if found, or null]",
  "reconciliation_summary": "[comprehensive summary including ALL payment amounts, fees, and billing terms found in tables and text]"
}`;

            try {
                // Convert image to base64
                const base64Image = await fileToBase64(imageFile);
                
                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: 'gpt-4o',
                        messages: [
                            {
                                role: "system",
                                content: "You are a contract analyst. Extract vendor information EXACTLY as requested. For business_description, provide ONLY a 2-3 word service category (like 'Waste Management' or 'Medical Supplies'), NOT a full sentence. Return ONLY valid JSON."
                            },
                            {
                                role: "user",
                                content: [
                                    {
                                        type: "text",
                                        text: prompt
                                    },
                                    {
                                        type: "image_url",
                                        image_url: {
                                            url: base64Image,
                                            detail: "high"
                                        }
                                    }
                                ]
                            }
                        ],
                        // response_format: { type: "json_object" }, // May not work with vision
                        max_tokens: 2000,
                        temperature: 0.1
                    })
                });
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('OpenAI API Error:', errorText);
                    throw new Error(`OpenAI Vision API request failed: ${response.status} - ${errorText}`);
                }
                
                const data = await response.json();
                console.log('OpenAI API response:', data);
                
                if (!data.choices || !data.choices[0] || !data.choices[0].message) {
                    throw new Error('Invalid API response structure');
                }
                
                const content = data.choices[0].message.content;
                console.log('API content:', content);
                
                return parseAIResponse(content);
                
            } catch (error) {
                console.error('AI Vision analysis error:', error);
                // Don't fall back to OCR - just try text analysis with better prompt
                console.log('Vision analysis encountered an issue, trying alternative method');
                
                // Try to get text without OCR
                if (uploadedFile && uploadedFile.type === 'application/pdf') {
                    const text = await extractTextFromPDF(uploadedFile);
                    return await analyzeContractWithText(text);
                }
                
                // For images, we really need vision to work
                throw new Error('Unable to analyze image contract. Please try a PDF version.');
            }
        }

        async function analyzeContractPDFWithVision(pdfFile) {
            try {
                // Convert PDF to images for vision analysis
                const arrayBuffer = await pdfFile.arrayBuffer();
                const pdf = await pdfjsLib.getDocument(arrayBuffer).promise;
                
                // Analyze ALL pages to get complete contract information
                const maxPages = Math.min(10, pdf.numPages); // Analyze up to 10 pages
                let combinedAnalysis = null;
                
                for (let pageNum = 1; pageNum <= maxPages; pageNum++) {
                    updateProgress(`Analyzing page ${pageNum} with AI Vision...`, 50 + (pageNum * 10));
                    
                    const page = await pdf.getPage(pageNum);
                    const viewport = page.getViewport({ scale: 2.0 }); // Higher resolution
                    
                    // Render page to canvas
                    const canvas = document.createElement('canvas');
                    const context = canvas.getContext('2d');
                    canvas.height = viewport.height;
                    canvas.width = viewport.width;
                    
                    await page.render({
                        canvasContext: context,
                        viewport: viewport
                    }).promise;
                    
                    // Convert canvas to blob
                    const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/png'));
                    
                    // Analyze this page with vision
                    const pageAnalysis = await analyzeContractWithVision(blob);
                    
                    // Combine results from multiple pages (simplified structure)
                    if (!combinedAnalysis) {
                        combinedAnalysis = pageAnalysis;
                    } else {
                        // Keep vendor name from first occurrence
                        if (!combinedAnalysis.vendor_name && pageAnalysis.vendor_name) {
                            combinedAnalysis.vendor_name = pageAnalysis.vendor_name;
                        }
                        
                        // Keep business description from first good occurrence
                        if (!combinedAnalysis.business_description && pageAnalysis.business_description) {
                            combinedAnalysis.business_description = pageAnalysis.business_description;
                        }
                        
                        // Combine summaries from all pages for comprehensive coverage
                        if (pageAnalysis.reconciliation_summary && pageAnalysis.reconciliation_summary !== "Unable to extract contract terms. Please review the contract manually.") {
                            if (combinedAnalysis.reconciliation_summary && 
                                combinedAnalysis.reconciliation_summary !== "Unable to extract contract terms. Please review the contract manually.") {
                                // Append new information from this page
                                combinedAnalysis.reconciliation_summary += " " + pageAnalysis.reconciliation_summary;
                            } else {
                                // Replace with better summary
                                combinedAnalysis.reconciliation_summary = pageAnalysis.reconciliation_summary;
                            }
                        }
                    }
                }
                
                return combinedAnalysis;
                
            } catch (error) {
                console.error('PDF Vision analysis error:', error);
                console.log('Vision analysis issue, using text extraction');
                // Extract text directly from PDF without OCR
                const text = await extractTextFromPDF(pdfFile);
                return await analyzeContractWithText(text);
            }
        }

        async function analyzeContractWithText(text) {
            const prompt = `Read this ENTIRE contract carefully and extract:

1. The vendor/supplier company name
2. IMPORTANT: Only provide a 2-3 word service category NAME (NOT a sentence). For example, if it's a waste/recycling company, just write "Waste Management". If it's a medical supply company, just write "Medical Supplies". Do NOT write full sentences like "provides waste and recycling services". Examples of correct format: "Waste Management", "Medical Supplies", "IT Services", "Building Maintenance", "Food Services", "Laboratory Testing", "Security Services", "Office Supplies", "Cleaning Services", "Equipment Rental"
3. The contract effective date (when the contract starts/began)
4. The contract renewal date or expiration date (if mentioned)
5. A comprehensive 3-5 sentence summary of ALL key terms for invoice reconciliation

IMPORTANT: Include ALL of these if present in the contract:
- Contract dates (effective date, start date, renewal date, expiration date)
- All payment amounts and fees (from tables, lists, or text)
- Billing frequency and invoice schedule
- Payment terms (Net 30, etc.)
- All services provided
- Any special billing rules or requirements
- Discounts, credits, or penalties

Contract text:
${text.substring(0, 15000)}

Return ONLY this JSON:
{
  "vendor_name": "[exact vendor name]",
  "business_description": "[ONLY 2-3 word category like 'Waste Management' - NOT a sentence]",
  "effective_date": "[YYYY-MM-DD format if found, or null]",
  "renewal_date": "[YYYY-MM-DD format if found, or null]",
  "reconciliation_summary": "[comprehensive summary of ALL billing/payment terms found]"
}`;

            try {
                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: 'gpt-4o',
                        messages: [
                            {
                                role: "system",
                                content: "You are a contract analyst. Extract vendor information EXACTLY as requested. For business_description, provide ONLY a 2-3 word service category (like 'Waste Management' or 'Medical Supplies'), NOT a full sentence. Return ONLY valid JSON."
                            },
                            {
                                role: "user", 
                                content: prompt
                            }
                        ],
                        // response_format: { type: "json_object" }, // May not work with vision
                        temperature: 0.1,
                        max_tokens: 2000
                    })
                });
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('OpenAI API Error:', errorText);
                    throw new Error(`OpenAI API request failed: ${response.status} - ${errorText}`);
                }
                
                const data = await response.json();
                console.log('OpenAI API response:', data);
                
                if (!data.choices || !data.choices[0] || !data.choices[0].message) {
                    throw new Error('Invalid API response structure');
                }
                
                const content = data.choices[0].message.content;
                console.log('API content:', content);
                
                return parseAIResponse(content);
                
            } catch (error) {
                console.error('AI text analysis error:', error);
                showToast(`Contract analysis failed: ${error.message}`, 'error');
                throw error;
            }
        }

        function formatDate(dateStr) {
            if (!dateStr || dateStr === 'null') return 'Not specified';
            try {
                const date = new Date(dateStr);
                if (isNaN(date.getTime())) return dateStr;
                return date.toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' });
            } catch (e) {
                return dateStr;
            }
        }
        
        function parseContractDate(dateStr) {
            if (!dateStr || dateStr === 'null') return null;
            
            try {
                // Handle various date formats
                let date;
                
                // Already in YYYY-MM-DD format
                if (/^\d{4}-\d{2}-\d{2}$/.test(dateStr)) {
                    return dateStr;
                }
                
                // MM/DD/YYYY or MM-DD-YYYY
                if (/^\d{1,2}[\/\-]\d{1,2}[\/\-]\d{4}$/.test(dateStr)) {
                    const parts = dateStr.split(/[\/\-]/);
                    date = new Date(parts[2], parts[0] - 1, parts[1]);
                }
                // DD/MM/YYYY or DD-MM-YYYY (European format)
                else if (/^\d{1,2}[\/\-]\d{1,2}[\/\-]\d{4}$/.test(dateStr) && parseInt(dateStr.split(/[\/\-]/)[0]) > 12) {
                    const parts = dateStr.split(/[\/\-]/);
                    date = new Date(parts[2], parts[1] - 1, parts[0]);
                }
                // Text format like "January 1, 2024"
                else {
                    date = new Date(dateStr);
                }
                
                if (date && !isNaN(date.getTime())) {
                    // Return in YYYY-MM-DD format
                    const year = date.getFullYear();
                    const month = String(date.getMonth() + 1).padStart(2, '0');
                    const day = String(date.getDate()).padStart(2, '0');
                    return `${year}-${month}-${day}`;
                }
            } catch (e) {
                console.error('Error parsing date:', e);
            }
            
            return null;
        }
        
        function cleanServiceCategory(description) {
            // If it's already short (2-4 words), return as is
            if (!description || description.split(' ').length <= 4) {
                // Check if it looks like a sentence (contains "provides", "offers", etc.)
                if (description && (description.includes('provides') || description.includes('offers') || description.includes('services'))) {
                    // Try to extract the key service type
                    if (description.toLowerCase().includes('waste') && description.toLowerCase().includes('recycl')) {
                        return 'Waste Management';
                    } else if (description.toLowerCase().includes('medical') || description.toLowerCase().includes('healthcare')) {
                        return 'Medical Supplies';
                    } else if (description.toLowerCase().includes('food') || description.toLowerCase().includes('dietary')) {
                        return 'Food Services';
                    } else if (description.toLowerCase().includes('clean')) {
                        return 'Cleaning Services';
                    } else if (description.toLowerCase().includes('it ') || description.toLowerCase().includes('technology')) {
                        return 'IT Services';
                    } else if (description.toLowerCase().includes('security')) {
                        return 'Security Services';
                    } else if (description.toLowerCase().includes('maintenance') || description.toLowerCase().includes('repair')) {
                        return 'Building Maintenance';
                    } else if (description.toLowerCase().includes('transport')) {
                        return 'Transportation Services';
                    } else if (description.toLowerCase().includes('lab')) {
                        return 'Laboratory Services';
                    } else if (description.toLowerCase().includes('equipment')) {
                        return 'Equipment Services';
                    } else {
                        // Try to extract the first 2-3 meaningful words
                        const words = description.replace(/provides|offers|services|including|and|the|for/gi, '').trim().split(' ');
                        return words.slice(0, 2).join(' ') + (words[1] ? '' : ' Services');
                    }
                }
                return description;
            }
            
            // If it's a long sentence, try to extract the service type
            const lowerDesc = description.toLowerCase();
            
            // Look for common patterns
            if (lowerDesc.includes('waste') && (lowerDesc.includes('management') || lowerDesc.includes('recycling'))) {
                return 'Waste Management';
            } else if (lowerDesc.includes('medical') || lowerDesc.includes('healthcare')) {
                return 'Medical Supplies';
            } else if (lowerDesc.includes('food') || lowerDesc.includes('dietary')) {
                return 'Food Services';
            } else if (lowerDesc.includes('cleaning') || lowerDesc.includes('janitorial')) {
                return 'Cleaning Services';
            } else if (lowerDesc.includes('information technology') || lowerDesc.includes('it ')) {
                return 'IT Services';
            } else {
                // Extract the first 2-3 meaningful words
                const words = description.replace(/provides|offers|services|including|and|the|for|company|vendor/gi, '').trim().split(' ');
                const serviceWords = words.filter(w => w.length > 2).slice(0, 2);
                return serviceWords.join(' ') + (serviceWords.length === 1 ? ' Services' : '');
            }
        }

        function parseAIResponse(content) {
            console.log('Raw AI response:', content);
            
            try {
                // Try to parse JSON directly
                const parsed = JSON.parse(content);
                console.log('Successfully parsed JSON:', parsed);
                
                // Clean up business_description if it's a sentence
                if (parsed.business_description) {
                    parsed.business_description = cleanServiceCategory(parsed.business_description);
                }
                
                return parsed;
            } catch (e) {
                console.log('Direct parse failed, attempting extraction...');
                
                // Try multiple regex patterns to find JSON
                const patterns = [
                    /\{[\s\S]*\}/,  // Standard JSON object
                    /```json\s*([\s\S]*?)```/,  // Markdown code block
                    /```\s*([\s\S]*?)```/,  // Generic code block
                ];
                
                for (const pattern of patterns) {
                    const match = content.match(pattern);
                    if (match) {
                        const jsonStr = match[1] || match[0];
                        try {
                            // Clean common issues
                            let cleaned = jsonStr
                                .trim()
                                .replace(/^```json\s*/g, '')
                                .replace(/```$/g, '')
                                .replace(/,\s*([}\]])/g, '$1')  // Remove trailing commas
                                .replace(/(['"])?([a-zA-Z0-9_]+)(['"])?\s*:/g, '"$2":')  // Fix unquoted keys
                                .replace(/'/g, '"')  // Replace single quotes
                                .replace(/[\u201C\u201D]/g, '"')  // Fix smart quotes
                                .replace(/\n/g, ' ')  // Remove newlines in strings
                                .replace(/\t/g, ' ');  // Remove tabs
                            
                            console.log('Attempting to parse cleaned JSON:', cleaned.substring(0, 200));
                            const parsed = JSON.parse(cleaned);
                            console.log('Successfully parsed after cleaning:', parsed);
                            
                            // Clean up business_description if it's a sentence
                            if (parsed.business_description) {
                                parsed.business_description = cleanServiceCategory(parsed.business_description);
                            }
                            
                            return parsed;
                        } catch (parseError) {
                            console.log('Parse attempt failed:', parseError.message);
                        }
                    }
                }
                
                // If all else fails, try to construct from keywords
                console.log('All parsing attempts failed, using fallback');
                const vendorMatch = content.match(/vendor[_\s]?name["']?\s*:\s*["']([^"']+)["']/i);
                const descMatch = content.match(/business[_\s]?description["']?\s*:\s*["']([^"']+)["']/i);
                const summaryMatch = content.match(/reconciliation[_\s]?summary["']?\s*:\s*["']([^"']+)["']/i);
                
                return {
                    vendor_name: vendorMatch ? vendorMatch[1] : "Unknown Vendor",
                    business_description: descMatch ? cleanServiceCategory(descMatch[1]) : "General Services",
                    reconciliation_summary: summaryMatch ? summaryMatch[1] : "Unable to extract contract terms. Please review the contract manually."
                };
            }
        }

        function showAIInsights(analysis) {
            const container = document.getElementById('insightsContainer');
            
            let insightsHtml = `
                <div class="insight-section">
                    <h4 style="color: var(--accent-cyan); margin-bottom: 15px;">📋 Contract Analysis</h4>
                    ${analysis.vendor_name ? `
                        <div class="insight-item">
                            <div class="insight-label">Vendor Name</div>
                            <div class="insight-value">${analysis.vendor_name}</div>
                        </div>
                    ` : ''}
                    ${analysis.business_description ? `
                        <div class="insight-item">
                            <div class="insight-label">Service Category</div>
                            <div class="insight-value">${analysis.business_description}</div>
                        </div>
                    ` : ''}
                    ${analysis.effective_date ? `
                        <div class="insight-item">
                            <div class="insight-label">Contract Effective Date</div>
                            <div class="insight-value">${formatDate(analysis.effective_date)}</div>
                        </div>
                    ` : ''}
                    ${analysis.renewal_date ? `
                        <div class="insight-item">
                            <div class="insight-label">Contract End/Renewal Date</div>
                            <div class="insight-value">${formatDate(analysis.renewal_date)}</div>
                        </div>
                    ` : ''}
                    <div class="insight-item">
                        <div class="insight-label">Date Added to System</div>
                        <div class="insight-value">${formatDate(new Date().toISOString().split('T')[0])}</div>
                    </div>
                    ${analysis.reconciliation_summary ? `
                        <div class="insight-item">
                            <div class="insight-label">Invoice Reconciliation Terms</div>
                            <div class="insight-value" style="line-height: 1.6; white-space: pre-wrap;">${analysis.reconciliation_summary}</div>
                        </div>
                    ` : ''}
                </div>
            `;
            
            container.innerHTML = insightsHtml;
        }

        function prefillVendorForm(analysis) {
            console.log('Prefilling form with analysis:', analysis);
            
            // Pre-fill vendor name from simplified structure
            if (analysis.vendor_name) {
                document.getElementById('vendorName').value = analysis.vendor_name;
                console.log('Set vendor name to:', analysis.vendor_name);
            }
            
            // Pre-fill business description
            if (analysis.business_description) {
                document.getElementById('businessDescription').value = analysis.business_description;
                console.log('Set business description to:', analysis.business_description);
            }
            
            // Add reconciliation summary to notes field
            if (analysis.reconciliation_summary) {
                document.getElementById('notes').value = analysis.reconciliation_summary;
                console.log('Set notes to reconciliation summary');
            }
            
            // Pre-fill dates if found in contract
            if (analysis.effective_date) {
                // Try to parse and format the date
                const effectiveDate = parseContractDate(analysis.effective_date);
                if (effectiveDate) {
                    document.getElementById('effectiveDate').value = effectiveDate;
                    console.log('Set effective date to:', effectiveDate);
                }
            } else {
                // Set today's date as default if not found
                document.getElementById('effectiveDate').value = new Date().toISOString().split('T')[0];
            }
            
            if (analysis.renewal_date) {
                const renewalDate = parseContractDate(analysis.renewal_date);
                if (renewalDate) {
                    document.getElementById('renewalDate').value = renewalDate;
                    console.log('Set renewal date to:', renewalDate);
                }
            }
            
            // Always set upload date to today
            document.getElementById('uploadDate').value = new Date().toISOString().split('T')[0];
            
            // Setup real-time validation and load any draft
            setupFormValidation();
            loadDraft();
        }
        
        function setupFormValidation() {
            const form = document.getElementById('addVendorForm');
            const inputs = form.querySelectorAll('input, textarea');
            
            inputs.forEach(input => {
                input.addEventListener('blur', () => validateField(input));
                input.addEventListener('input', () => {
                    clearFieldError(input);
                    saveDraft(); // Auto-save on input
                });
            });
        }
        
        function validateField(field) {
            const value = field.value.trim();
            const isRequired = field.hasAttribute('required');
            
            clearFieldError(field);
            
            if (isRequired && !value) {
                showFieldError(field, 'This field is required');
                return false;
            }
            
            if (field.type === 'date' && value) {
                const date = new Date(value);
                const today = new Date();
                const oneYearAgo = new Date(today.getFullYear() - 10, today.getMonth(), today.getDate());
                const oneYearFromNow = new Date(today.getFullYear() + 10, today.getMonth(), today.getDate());
                
                if (date < oneYearAgo || date > oneYearFromNow) {
                    showFieldError(field, 'Please enter a reasonable contract date');
                    return false;
                }
            }
            
            return true;
        }
        
        function showFieldError(field, message) {
            field.style.borderColor = 'var(--error)';
            let errorDiv = field.parentNode.querySelector('.field-error');
            if (!errorDiv) {
                errorDiv = document.createElement('div');
                errorDiv.className = 'field-error';
                errorDiv.style.color = 'var(--error)';
                errorDiv.style.fontSize = '12px';
                errorDiv.style.marginTop = '4px';
                field.parentNode.appendChild(errorDiv);
            }
            errorDiv.textContent = message;
        }
        
        function clearFieldError(field) {
            field.style.borderColor = '';
            const errorDiv = field.parentNode.querySelector('.field-error');
            if (errorDiv) {
                errorDiv.remove();
            }
        }

        async function saveVendor() {
            const form = document.getElementById('addVendorForm');
            const formData = new FormData(form);
            
            // Validate required fields
            const name = formData.get('vendorName').trim();
            const businessDescription = formData.get('businessDescription').trim();
            const reconciliationTerms = formData.get('notes').trim();
            const effectiveDate = formData.get('effectiveDate');
            const renewalDate = formData.get('renewalDate');
            const uploadDate = formData.get('uploadDate') || new Date().toISOString().split('T')[0];
            
            if (!name || !businessDescription || !reconciliationTerms || !effectiveDate) {
                showToast('Please fill in all required fields', 'error');
                return;
            }
            
            if (!uploadedFile || !contractAnalysis) {
                showToast('Contract analysis not completed', 'error');
                return;
            }
            
            try {
                // Create streamlined vendor object with only essential AP data
                const vendor = {
                    id: Date.now().toString(),
                    
                    // Basic vendor info
                    name: name, // For backward compatibility
                    vendor_name: name,
                    business_description: businessDescription,
                    business_type: businessDescription, // For dashboard compatibility
                    description: businessDescription, // For backward compatibility
                    effective_date: effectiveDate,
                    renewal_date: renewalDate || null,
                    upload_date: uploadDate,
                    contract_date: effectiveDate, // For backward compatibility
                    reconciliation_summary: reconciliationTerms,
                    
                    // AI Analysis results (simplified)
                    ai_extracted_name: contractAnalysis.vendor_name || '',
                    ai_extracted_description: contractAnalysis.business_description || '',
                    ai_extracted_summary: contractAnalysis.reconciliation_summary || '',
                    
                    // Contract file reference
                    contract_file: {
                        name: uploadedFile.name,
                        upload_date: new Date().toISOString(),
                        data: await fileToBase64(uploadedFile)
                    },
                    
                    // System metadata
                    status: 'active',
                    created_at: new Date().toISOString(),
                    last_updated: new Date().toISOString(),
                    invoice_count: 0
                };
                
                // Check for duplicate vendors
                const existingVendors = JSON.parse(localStorage.getItem('vendors') || '[]');
                console.log('Before saving - existing vendors:', existingVendors.length);
                
                const duplicate = existingVendors.find(v => 
                    v.vendor_name?.toLowerCase() === name.toLowerCase() || 
                    v.name?.toLowerCase() === name.toLowerCase()
                );
                
                if (duplicate) {
                    const confirmed = confirm(`A vendor named "${name}" already exists. Do you want to create it anyway?`);
                    if (!confirmed) {
                        return;
                    }
                }
                
                existingVendors.push(vendor);
                localStorage.setItem('vendors', JSON.stringify(existingVendors));
                
                // Verify save worked
                const verifyVendors = JSON.parse(localStorage.getItem('vendors') || '[]');
                const savedVendor = verifyVendors.find(v => v.id === vendor.id);
                
                if (!savedVendor) {
                    throw new Error('Failed to save vendor to storage');
                }
                
                console.log('Vendor saved successfully:', vendor);
                console.log('After saving - total vendors in storage:', verifyVendors.length);
                console.log('Verification - last vendor saved:', verifyVendors[verifyVendors.length - 1]);
                
                // Clear draft after successful save
                clearDraft();
                
                showToast('Vendor profile created successfully!', 'success');
                
                // Redirect to dashboard after short delay
                setTimeout(() => {
                    window.location.href = 'index.html';
                }, 1500);
                
            } catch (error) {
                console.error('Error saving vendor:', error);
                
                // Enhanced error recovery
                if (error.message.includes('storage')) {
                    showToast('Storage error. Please try again or clear browser data.', 'error');
                } else if (error.message.includes('duplicate')) {
                    showToast('This vendor name already exists. Please use a different name.', 'error');
                } else {
                    showToast('Error saving vendor: ' + error.message + '. Please try again.', 'error');
                }
                
                // Keep form data for retry
                saveDraft();
            }
        }

        function fileToBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.readAsDataURL(file);
                reader.onload = () => resolve(reader.result);
                reader.onerror = error => reject(error);
            });
        }
    </script>
</body>
</html>